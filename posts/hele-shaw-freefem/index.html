<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FreeFem++によるヘレショウ流れのシミュレーション | My Site</title><meta name=keywords content="FreeFem++,Simulation,Hele-Shaw"><meta name=description content="ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。"><meta name=author content><link rel=canonical href=https://hogexcom.github.io/my-site/posts/hele-shaw-freefem/><link crossorigin=anonymous href=/my-site/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hogexcom.github.io/my-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hogexcom.github.io/my-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hogexcom.github.io/my-site/favicon-32x32.png><link rel=apple-touch-icon href=https://hogexcom.github.io/my-site/apple-touch-icon.png><link rel=mask-icon href=https://hogexcom.github.io/my-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hogexcom.github.io/my-site/posts/hele-shaw-freefem/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script><meta property="og:url" content="https://hogexcom.github.io/my-site/posts/hele-shaw-freefem/"><meta property="og:site_name" content="My Site"><meta property="og:title" content="FreeFem++によるヘレショウ流れのシミュレーション"><meta property="og:description" content="ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。"><meta property="og:locale" content="ja-JP"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-21T10:00:00+09:00"><meta property="article:modified_time" content="2026-01-21T10:00:00+09:00"><meta property="article:tag" content="FreeFem++"><meta property="article:tag" content="Simulation"><meta property="article:tag" content="Hele-Shaw"><meta property="og:image" content="https://hogexcom.github.io/my-site/images/hele-shaw-freefem-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hogexcom.github.io/my-site/images/hele-shaw-freefem-cover.png"><meta name=twitter:title content="FreeFem++によるヘレショウ流れのシミュレーション"><meta name=twitter:description content="ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hogexcom.github.io/my-site/posts/"},{"@type":"ListItem","position":2,"name":"FreeFem++によるヘレショウ流れのシミュレーション","item":"https://hogexcom.github.io/my-site/posts/hele-shaw-freefem/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FreeFem++によるヘレショウ流れのシミュレーション","name":"FreeFem\u002b\u002bによるヘレショウ流れのシミュレーション","description":"ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。","keywords":["FreeFem++","Simulation","Hele-Shaw"],"articleBody":"ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。\nシミュレーション結果 以下はシミュレーション結果の動画です。初期形状から徐々に円形へと緩和していく様子が確認できます。\nYour browser does not support the video tag. FreeFem++コード 使用したFreeFem++のコード (ヘレショウ問題.edp) は以下の通りです。 表面張力による曲率の効果を取り入れ、境界をラグランジュ的に移動させています。\nload \"Curvature\" ifstream file(\"pi_border_data.txt\"); int n; file \u003e\u003e n; // 点の数を読み込み // 座標データを格納する配列 real[int] xdata(n), ydata(n); // 座標データを読み込み for(int i = 0; i \u003c n; i++) { file \u003e\u003e xdata[i] \u003e\u003e ydata[i]; } // より安全な線形補間でborderを定義 border C(u=0,1) { // パラメータを[0,1]に正規化 real t = u * (n-1); int k = int(t); real s = t - k; // 境界条件を厳密に処理 if(k \u003e= n-1) { k = n-2; s = 1.0; } if(k \u003c 0) { k = 0; s = 0.0; } // 線形補間 x = (1-s) * xdata[k] + s * xdata[k+1]; y = (1-s) * ydata[k] + s * ydata[k+1]; label = 1; } mesh Th = buildmesh(C(200)); Th = adaptmesh(Th, hmin=0.03, hmax=0.3); real sigma = 1.0; real dt = 0.0005; for (int i = 0; i \u003c 10000; i++) { fespace Vh(Th, P1); Vh u, v, kb; int[int] labels = [1]; // ラベル1の境界 real[int,int] borderdata(1,3); // [x, y, u値]を格納 real length = extractborder(Th, labels, borderdata); int nedge = borderdata.m - 1; real[int] tx(nedge), ty(nedge), lenedge(nedge); for (int j = 0; j \u003c nedge; j++) { real ex = borderdata(0, j+1) - borderdata(0, j); real ey = borderdata(1, j+1) - borderdata(1, j); real len = sqrt(ex*ex + ey*ey); if (len \u003c= 0) len = 1e-12; lenedge[j] = len; tx[j] = ex / len; ty[j] = ey / len; } real[int] phi(nedge); for (int j = 0; j \u003c nedge; j++) { int j1 = (j + 1) % nedge; // dot product real dot = tx[j] * tx[j1] + ty[j] * ty[j1]; // cross product (z-component) to check orientation real cross = tx[j] * ty[j1] - ty[j] * tx[j1]; if (dot \u003e 1.0) dot = 1.0; if (dot \u003c -1.0) dot = -1.0; real phival = acos(dot); // If right turn (negative cross product), angle should be negative if (cross \u003c 0) phival = -phival; phi[j] = phival; } real[int] kvertex(borderdata.m); for (int j = 0; j \u003c nedge; j++) { int jm = (j - 1 + nedge) % nedge; kvertex[j] = (tan(phi[j] / 2.0) + tan(phi[jm] / 2.0)) / lenedge[j]; } kvertex[nedge] = kvertex[0]; kb[] = 0; // Boundary mapping: Map physical boundary vertices to Vh DOF indices Vh valIndex; for(int k=0; k\u003cVh.ndof; ++k) valIndex[][k] = k; int[int] bnd(borderdata.m); for(int j=0; j\u003cborderdata.m; ++j) { bnd[j] = int(valIndex(borderdata(0, j), borderdata(1, j)) + 0.5); } for (int j = 0; j \u003c bnd.n; j++) { kb[][bnd[j]] = kvertex[j]; } problem Poisson(u, v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) + on(1, u = sigma * kb); Poisson; if (i % 20 == 0) { string filename = \"out/heleshaw_\" + i + \".ps\"; plot(Th, u, wait=0, value=true, fill=true, ps=filename, bb=[[-6, -7], [6, 3]]); } Vh dux = dx(u); Vh duy = dy(u); // 法線微分と頂点法線速度の準備 real[int] normalderivative(nedge); for (int j = 0; j \u003c nedge; j++) { real nx = ty[j]; real ny = -tx[j]; real mx = (borderdata(0, j+1) + borderdata(0, j)) / 2; real my = (borderdata(1, j+1) + borderdata(1, j)) / 2; normalderivative[j] = dux(mx, my) * nx + duy(mx, my) * ny; } // 頂点法線速度 V = (v_{j-1} + v_j) / (2 * cos(phi_j/2)) real[int] cosi(nedge); real[int] Vvertex(borderdata.m); real[int] nxb(nedge), nyb(nedge); real[int] nxv(borderdata.m), nyv(borderdata.m); // Prepare edge normals (for averaging to vertex normal) for (int j = 0; j \u003c nedge; j++) { nxb[j] = ty[j]; nyb[j] = -tx[j]; } for (int j = 0; j \u003c nedge; j++) { int jm = (j - 1 + nedge) % nedge; // Calculate angle at vertex j (between edge jm and edge j) real dot = tx[jm] * tx[j] + ty[jm] * ty[j]; real cross = tx[jm] * ty[j] - ty[jm] * tx[j]; if (dot \u003e 1.0) dot = 1.0; if (dot \u003c -1.0) dot = -1.0; real phival = acos(dot); if (cross \u003c 0) phival = -phival; cosi[j] = cos(phival / 2.0); if (abs(cosi[j]) \u003c 1e-12) cosi[j] = 1e-12; // Velocity at vertex j uses normal derivatives of edge jm and edge j Vvertex[j] = (normalderivative[jm] + normalderivative[j]) / (2.0 * cosi[j]); // Vertex normal at j real nx = nxb[jm] + nxb[j]; real ny = nyb[jm] + nyb[j]; real nlen = sqrt(nx*nx + ny*ny); if (nlen \u003c= 0) nlen = 1e-12; nxv[j] = nx / nlen; nyv[j] = ny / nlen; } Vvertex[nedge] = Vvertex[0]; nxv[nedge] = nxv[0]; nyv[nedge] = nyv[0]; border B(t=0, borderdata.m-1) { x = borderdata(0, t) - dt * Vvertex[t] * nxv[t]; y = borderdata(1, t) - dt * Vvertex[t] * nyv[t]; label = 1; // ラベルを設定 } Th = buildmesh(B(borderdata.m-1), fixedborder=1); Th = adaptmesh(Th, hmin=0.03, hmax=0.3); } ダウンロード ソースコード (.edp) 境界データ (.txt) ","wordCount":"772","inLanguage":"en","image":"https://hogexcom.github.io/my-site/images/hele-shaw-freefem-cover.png","datePublished":"2026-01-21T10:00:00+09:00","dateModified":"2026-01-21T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://hogexcom.github.io/my-site/posts/hele-shaw-freefem/"},"publisher":{"@type":"Organization","name":"My Site","logo":{"@type":"ImageObject","url":"https://hogexcom.github.io/my-site/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hogexcom.github.io/my-site/ accesskey=h title="My Site (Alt + H)">My Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">FreeFem++によるヘレショウ流れのシミュレーション</h1><div class=post-meta><span title='2026-01-21 10:00:00 +0900 +0900'>January 21, 2026</span></div></header><figure class=entry-cover><img loading=eager src=https://hogexcom.github.io/my-site/images/hele-shaw-freefem-cover.png alt=ヘレショウシミュレーションの可視化></figure><div class=post-content><p>ヘレショウセル内での定常状態での圧力により、領域が丸まっていく数値計算を有限要素法FreeFem++で実現しました。</p><h2 id=シミュレーション結果>シミュレーション結果<a hidden class=anchor aria-hidden=true href=#シミュレーション結果>#</a></h2><p>以下はシミュレーション結果の動画です。初期形状から徐々に円形へと緩和していく様子が確認できます。</p><video controls width=100%>
<source src=/my-site/files/hele-shaw-freefem/heleshaw_freefem.mp4 type=video/mp4>Your browser does not support the video tag.</video><h2 id=freefemコード>FreeFem++コード<a hidden class=anchor aria-hidden=true href=#freefemコード>#</a></h2><p>使用したFreeFem++のコード (<code>ヘレショウ問題.edp</code>) は以下の通りです。
表面張力による曲率の効果を取り入れ、境界をラグランジュ的に移動させています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>load <span style=color:#e6db74>&#34;Curvature&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ifstream file(<span style=color:#e6db74>&#34;pi_border_data.txt&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>file <span style=color:#f92672>&gt;&gt;</span> n; <span style=color:#75715e>// 点の数を読み込み
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 座標データを格納する配列
</span></span></span><span style=display:flex><span>real[<span style=color:#66d9ef>int</span>] xdata(n), ydata(n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 座標データを読み込み
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    file <span style=color:#f92672>&gt;&gt;</span> xdata[i] <span style=color:#f92672>&gt;&gt;</span> ydata[i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// より安全な線形補間でborderを定義
</span></span></span><span style=display:flex><span>border <span style=color:#a6e22e>C</span>(u<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// パラメータを[0,1]に正規化
</span></span></span><span style=display:flex><span>    real t <span style=color:#f92672>=</span> u <span style=color:#f92672>*</span> (n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(t);
</span></span><span style=display:flex><span>    real s <span style=color:#f92672>=</span> t <span style=color:#f92672>-</span> k;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 境界条件を厳密に処理
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 線形補間
</span></span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s) <span style=color:#f92672>*</span> xdata[k] <span style=color:#f92672>+</span> s <span style=color:#f92672>*</span> xdata[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s) <span style=color:#f92672>*</span> ydata[k] <span style=color:#f92672>+</span> s <span style=color:#f92672>*</span> ydata[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    label <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mesh Th <span style=color:#f92672>=</span> buildmesh(C(<span style=color:#ae81ff>200</span>));
</span></span><span style=display:flex><span>Th <span style=color:#f92672>=</span> adaptmesh(Th, hmin<span style=color:#f92672>=</span><span style=color:#ae81ff>0.03</span>, hmax<span style=color:#f92672>=</span><span style=color:#ae81ff>0.3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real sigma <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>real dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0005</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    fespace <span style=color:#a6e22e>Vh</span>(Th, P1);
</span></span><span style=display:flex><span>    Vh u, v, kb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>[<span style=color:#66d9ef>int</span>] labels <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>]; <span style=color:#75715e>// ラベル1の境界
</span></span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>] borderdata(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// [x, y, u値]を格納
</span></span></span><span style=display:flex><span>    real length <span style=color:#f92672>=</span> extractborder(Th, labels, borderdata);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> nedge <span style=color:#f92672>=</span> borderdata.m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] tx(nedge), ty(nedge), lenedge(nedge);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        real ex <span style=color:#f92672>=</span> borderdata(<span style=color:#ae81ff>0</span>, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> borderdata(<span style=color:#ae81ff>0</span>, j);
</span></span><span style=display:flex><span>        real ey <span style=color:#f92672>=</span> borderdata(<span style=color:#ae81ff>1</span>, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> borderdata(<span style=color:#ae81ff>1</span>, j);
</span></span><span style=display:flex><span>        real len <span style=color:#f92672>=</span> sqrt(ex<span style=color:#f92672>*</span>ex <span style=color:#f92672>+</span> ey<span style=color:#f92672>*</span>ey);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-12</span>;
</span></span><span style=display:flex><span>        lenedge[j] <span style=color:#f92672>=</span> len;
</span></span><span style=display:flex><span>        tx[j] <span style=color:#f92672>=</span> ex <span style=color:#f92672>/</span> len;
</span></span><span style=display:flex><span>        ty[j] <span style=color:#f92672>=</span> ey <span style=color:#f92672>/</span> len;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] phi(nedge);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> j1 <span style=color:#f92672>=</span> (j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> nedge;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dot product
</span></span></span><span style=display:flex><span>        real dot <span style=color:#f92672>=</span> tx[j] <span style=color:#f92672>*</span> tx[j1] <span style=color:#f92672>+</span> ty[j] <span style=color:#f92672>*</span> ty[j1];
</span></span><span style=display:flex><span>        <span style=color:#75715e>// cross product (z-component) to check orientation
</span></span></span><span style=display:flex><span>        real cross <span style=color:#f92672>=</span> tx[j] <span style=color:#f92672>*</span> ty[j1] <span style=color:#f92672>-</span> ty[j] <span style=color:#f92672>*</span> tx[j1];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dot <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1.0</span>) dot <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dot <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>) dot <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        real phival <span style=color:#f92672>=</span> acos(dot);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If right turn (negative cross product), angle should be negative
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cross <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) phival <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>phival;
</span></span><span style=display:flex><span>        phi[j] <span style=color:#f92672>=</span> phival;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] kvertex(borderdata.m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> jm <span style=color:#f92672>=</span> (j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> nedge) <span style=color:#f92672>%</span> nedge;
</span></span><span style=display:flex><span>        kvertex[j] <span style=color:#f92672>=</span> (tan(phi[j] <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>+</span> tan(phi[jm] <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>)) <span style=color:#f92672>/</span> lenedge[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    kvertex[nedge] <span style=color:#f92672>=</span> kvertex[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    kb[] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Boundary mapping: Map physical boundary vertices to Vh DOF indices
</span></span></span><span style=display:flex><span>    Vh valIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; k<span style=color:#f92672>&lt;</span>Vh.ndof; <span style=color:#f92672>++</span>k) valIndex[][k] <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>[<span style=color:#66d9ef>int</span>] bnd(borderdata.m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;</span>borderdata.m; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>        bnd[j] <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(valIndex(borderdata(<span style=color:#ae81ff>0</span>, j), borderdata(<span style=color:#ae81ff>1</span>, j)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> bnd.n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        kb[][bnd[j]] <span style=color:#f92672>=</span> kvertex[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    problem <span style=color:#a6e22e>Poisson</span>(u, v)
</span></span><span style=display:flex><span>        <span style=color:#f92672>=</span> int2d(Th)(dx(u)<span style=color:#f92672>*</span>dx(v) <span style=color:#f92672>+</span> dy(u)<span style=color:#f92672>*</span>dy(v))
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> on(<span style=color:#ae81ff>1</span>, u <span style=color:#f92672>=</span> sigma <span style=color:#f92672>*</span> kb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Poisson;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> <span style=color:#ae81ff>20</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        string filename <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;out/heleshaw_&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.ps&#34;</span>;
</span></span><span style=display:flex><span>        plot(Th, u, wait<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, value<span style=color:#f92672>=</span>true, fill<span style=color:#f92672>=</span>true, ps<span style=color:#f92672>=</span>filename, bb<span style=color:#f92672>=</span><span style=color:#a6e22e>[[-6, -7], [6, 3]]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Vh dux <span style=color:#f92672>=</span> dx(u);
</span></span><span style=display:flex><span>    Vh duy <span style=color:#f92672>=</span> dy(u);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 法線微分と頂点法線速度の準備
</span></span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] normalderivative(nedge);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        real nx <span style=color:#f92672>=</span> ty[j];
</span></span><span style=display:flex><span>        real ny <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>tx[j];
</span></span><span style=display:flex><span>        real mx <span style=color:#f92672>=</span> (borderdata(<span style=color:#ae81ff>0</span>, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> borderdata(<span style=color:#ae81ff>0</span>, j)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        real my <span style=color:#f92672>=</span> (borderdata(<span style=color:#ae81ff>1</span>, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> borderdata(<span style=color:#ae81ff>1</span>, j)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        normalderivative[j] <span style=color:#f92672>=</span> dux(mx, my) <span style=color:#f92672>*</span> nx <span style=color:#f92672>+</span> duy(mx, my) <span style=color:#f92672>*</span> ny;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 頂点法線速度 V = (v_{j-1} + v_j) / (2 * cos(phi_j/2))
</span></span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] cosi(nedge);
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] Vvertex(borderdata.m);
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] nxb(nedge), nyb(nedge);
</span></span><span style=display:flex><span>    real[<span style=color:#66d9ef>int</span>] nxv(borderdata.m), nyv(borderdata.m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Prepare edge normals (for averaging to vertex normal)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        nxb[j] <span style=color:#f92672>=</span> ty[j];
</span></span><span style=display:flex><span>        nyb[j] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>tx[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> nedge; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> jm <span style=color:#f92672>=</span> (j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> nedge) <span style=color:#f92672>%</span> nedge;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate angle at vertex j (between edge jm and edge j)
</span></span></span><span style=display:flex><span>        real dot <span style=color:#f92672>=</span> tx[jm] <span style=color:#f92672>*</span> tx[j] <span style=color:#f92672>+</span> ty[jm] <span style=color:#f92672>*</span> ty[j];
</span></span><span style=display:flex><span>        real cross <span style=color:#f92672>=</span> tx[jm] <span style=color:#f92672>*</span> ty[j] <span style=color:#f92672>-</span> ty[jm] <span style=color:#f92672>*</span> tx[j];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dot <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1.0</span>) dot <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dot <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>) dot <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        real phival <span style=color:#f92672>=</span> acos(dot);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cross <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) phival <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>phival;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        cosi[j] <span style=color:#f92672>=</span> cos(phival <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (abs(cosi[j]) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1e-12</span>) cosi[j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-12</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Velocity at vertex j uses normal derivatives of edge jm and edge j
</span></span></span><span style=display:flex><span>        Vvertex[j] <span style=color:#f92672>=</span> (normalderivative[jm] <span style=color:#f92672>+</span> normalderivative[j]) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> cosi[j]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Vertex normal at j
</span></span></span><span style=display:flex><span>        real nx <span style=color:#f92672>=</span> nxb[jm] <span style=color:#f92672>+</span> nxb[j];
</span></span><span style=display:flex><span>        real ny <span style=color:#f92672>=</span> nyb[jm] <span style=color:#f92672>+</span> nyb[j];
</span></span><span style=display:flex><span>        real nlen <span style=color:#f92672>=</span> sqrt(nx<span style=color:#f92672>*</span>nx <span style=color:#f92672>+</span> ny<span style=color:#f92672>*</span>ny);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nlen <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) nlen <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-12</span>;
</span></span><span style=display:flex><span>        nxv[j] <span style=color:#f92672>=</span> nx <span style=color:#f92672>/</span> nlen;
</span></span><span style=display:flex><span>        nyv[j] <span style=color:#f92672>=</span> ny <span style=color:#f92672>/</span> nlen;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Vvertex[nedge] <span style=color:#f92672>=</span> Vvertex[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    nxv[nedge] <span style=color:#f92672>=</span> nxv[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    nyv[nedge] <span style=color:#f92672>=</span> nyv[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    border <span style=color:#a6e22e>B</span>(t<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, borderdata.m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> borderdata(<span style=color:#ae81ff>0</span>, t) <span style=color:#f92672>-</span> dt <span style=color:#f92672>*</span> Vvertex[t] <span style=color:#f92672>*</span> nxv[t];
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> borderdata(<span style=color:#ae81ff>1</span>, t) <span style=color:#f92672>-</span> dt <span style=color:#f92672>*</span> Vvertex[t] <span style=color:#f92672>*</span> nyv[t];
</span></span><span style=display:flex><span>        label <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// ラベルを設定
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    Th <span style=color:#f92672>=</span> buildmesh(B(borderdata.m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), fixedborder<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    Th <span style=color:#f92672>=</span> adaptmesh(Th, hmin<span style=color:#f92672>=</span><span style=color:#ae81ff>0.03</span>, hmax<span style=color:#f92672>=</span><span style=color:#ae81ff>0.3</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ダウンロード>ダウンロード<a hidden class=anchor aria-hidden=true href=#ダウンロード>#</a></h2><ul><li><a href=/my-site/files/hele-shaw-freefem/%E3%83%98%E3%83%AC%E3%82%B7%E3%83%A7%E3%82%A6%E5%95%8F%E9%A1%8C.edp>ソースコード (.edp)</a></li><li><a href=/my-site/files/hele-shaw-freefem/pi_border_data.txt>境界データ (.txt)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hogexcom.github.io/my-site/tags/freefem++/>FreeFem++</a></li><li><a href=https://hogexcom.github.io/my-site/tags/simulation/>Simulation</a></li><li><a href=https://hogexcom.github.io/my-site/tags/hele-shaw/>Hele-Shaw</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://hogexcom.github.io/my-site/>My Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>