import"./modulepreload-polyfill-B5Qt9EMX.js";import{r as L,B as se,a as ae,j as m,D as ot,T as Rt,L as Re,F as Pe,C as G,S as N,V as H,b as K,d as on,e as qe,f as Et,g as we,M as ce,h as at,i as le,k as St,P as $e,l as bt,m as D,I as an,Q as re,n as cn,O as ve,o as _t,p as ln,q as un,s as Mt,N as fn,t as hn,u as pn,v as Ze,w as Lt,R as Le,x as dn,y as Je,z as mn,A as He,E as It,G as Ct,H as be,J as Ie,K as Ft,U as ct,W as gn,X as Pt,Y as xn,Z as yn,_ as _e,$ as Dt,a0 as X,a1 as vn,a2 as kt,a3 as Ot,a4 as Qe,a5 as Tn,a6 as jt,a7 as wn,a8 as et,a9 as tt,aa as nt,ab as Ne,ac as oe,ad as An,ae as Rn,af as En,ag as Sn,ah as Ce,ai as bn,aj as Oe,ak as _n,al as Mn,am as Ln,an as In,ao as Cn,ap as Fn,aq as ge,ar as Pn,as as Dn,at as kn,au as On,c as jn}from"./vendor-three-DWdYVK8p.js";import{u as Nn}from"./usePyodide-Bpngy5wJ.js";import"./vendor-react-CCYiWZgt.js";function lt(u){const e=u.vertices;if(e.length===0)return{center:[0,0,0],size:1,minY:0};let t=1/0,s=1/0,n=1/0,r=-1/0,i=-1/0,o=-1/0;for(const[d,x,v]of e)t=Math.min(t,d),s=Math.min(s,x),n=Math.min(n,v),r=Math.max(r,d),i=Math.max(i,x),o=Math.max(o,v);const a=[(t+r)/2,(s+i)/2,(n+o)/2],l=r-t,f=i-s,c=o-n,h=Math.max(l,f,c);return{center:a,size:h,minY:s}}function dt({mesh:u,color:e,position:t=[0,0,0],label:s,boundingInfo:n}){const{geometry:r,labelY:i}=L.useMemo(()=>{const o=new se,a=n||lt(u),[l,f,c]=a.center,h=a.size>0?1.5/a.size:1,d=(f-a.minY)*h,x=new Float32Array(u.vertices.length*3);for(let y=0;y<u.vertices.length;y++){const[T,g,w]=u.vertices[y];x[y*3]=(T-l)*h,x[y*3+1]=(g-f)*h+d,x[y*3+2]=(w-c)*h}o.setAttribute("position",new ae(x,3));const v=new Uint32Array(u.faces.flat());o.setIndex(new ae(v,1)),o.computeVertexNormals(),o.computeBoundingBox();const p=o.boundingBox?o.boundingBox.max.y+.15:.8;return{geometry:o,labelY:p}},[u,n]);return m.jsxs("group",{position:t,children:[m.jsx("mesh",{geometry:r,children:m.jsx("meshStandardMaterial",{color:e,side:ot,flatShading:!1})}),m.jsx(Rt,{position:[0,i,0],fontSize:.1,color:"white",anchorX:"center",anchorY:"middle",children:s})]})}function Bn(u,e,t){const s=Math.max(Math.abs(e),Math.abs(t)),n=s>0?u/s:0;if(n<0){const r=1+n;return[r,r,1]}else{const r=1-n;return[1,r,r]}}function Un({mesh:u,eigenvector:e,position:t=[0,0,0],label:s,boundingInfo:n}){const{geometry:r,labelY:i}=L.useMemo(()=>{const o=new se,a=n||lt(u),[l,f,c]=a.center,h=a.size>0?1.5/a.size:1,d=(f-a.minY)*h,x=[],v=[];let p=0,y=0;e&&e.length>0&&(p=Math.min(...e),y=Math.max(...e));for(const g of u.faces)for(const w of g){const[R,E,b]=u.vertices[w];if(x.push((R-l)*h,(E-f)*h+d,(b-c)*h),e&&e.length>w){const[A,M,_]=Bn(e[w],p,y);v.push(A,M,_)}else v.push(.5,.5,.5)}o.setAttribute("position",new ae(new Float32Array(x),3)),o.setAttribute("color",new ae(new Float32Array(v),3)),o.computeVertexNormals(),o.computeBoundingBox();const T=o.boundingBox?o.boundingBox.max.y+.15:.8;return{geometry:o,labelY:T}},[u,e,n]);return m.jsxs("group",{position:t,children:[m.jsx("mesh",{geometry:r,children:m.jsx("meshStandardMaterial",{vertexColors:!0,side:ot,flatShading:!1})}),m.jsx(Rt,{position:[0,i,0],fontSize:.1,color:"white",anchorX:"center",anchorY:"middle",children:s})]})}function Nt(u,e){if(u.length===0)return 1;if(u.length===1)return u[0].y;const t=[...u].sort((s,n)=>s.x-n.x);if(e<=t[0].x)return t[0].y;if(e>=t[t.length-1].x)return t[t.length-1].y;for(let s=0;s<t.length-1;s++)if(e>=t[s].x&&e<=t[s+1].x){const n=(e-t[s].x)/(t[s+1].x-t[s].x);return t[s].y+n*(t[s+1].y-t[s].y)}return 1}function Hn(u,e=100){let t=0;for(let s=0;s<=e;s++){const n=s/e;t+=Nt(u,n)}return t/(e+1)}function Gn({points:u,onChange:e,maxEigenpairs:t,disabled:s}){const n=L.useRef(null),[r,i]=L.useState(null),[o,a]=L.useState(null),l=280,f=150,c={top:20,right:20,bottom:30,left:35},h=l-c.left-c.right,d=f-c.top-c.bottom,x=A=>c.left+A*h,v=A=>c.top+(1-A/2)*d,p=A=>Math.max(0,Math.min(1,(A-c.left)/h)),y=A=>Math.max(0,Math.min(2,2*(1-(A-c.top)/d))),T=L.useCallback(()=>{if(u.length===0)return"";const A=[...u].sort((_,S)=>_.x-S.x),M=[];M.push(`M ${x(0)} ${v(A[0].y)}`),M.push(`L ${x(A[0].x)} ${v(A[0].y)}`);for(let _=1;_<A.length;_++)M.push(`L ${x(A[_].x)} ${v(A[_].y)}`);return M.push(`L ${x(1)} ${v(A[A.length-1].y)}`),M.join(" ")},[u]),g=L.useCallback((A,M)=>{s||(A.preventDefault(),i(M))},[s]),w=L.useCallback(A=>{if(r===null||s)return;const M=n.current;if(!M)return;const _=M.getBoundingClientRect(),S=p(A.clientX-_.left),F=y(A.clientY-_.top),z=[...u];z[r]={x:S,y:F},e(z)},[r,u,e,s]),R=L.useCallback(()=>{i(null)},[]),E=L.useCallback(A=>{if(s)return;const M=n.current;if(!M)return;const _=M.getBoundingClientRect(),S=p(A.clientX-_.left),F=y(A.clientY-_.top),z=.05,ee=u.findIndex(V=>Math.abs(V.x-S)<z&&Math.abs(V.y-F)<.2);if(ee!==-1&&u.length>2){const V=u.filter((j,Z)=>Z!==ee);e(V)}else e([...u,{x:S,y:F}])},[u,e,s]);L.useEffect(()=>{const A=()=>i(null);return window.addEventListener("mouseup",A),()=>window.removeEventListener("mouseup",A)},[]);const b=[0,.5,1,1.5,2];return m.jsxs("div",{className:"curve-editor",children:[m.jsxs("svg",{ref:n,width:l,height:f,onMouseMove:w,onMouseUp:R,onDoubleClick:E,style:{cursor:s?"not-allowed":r!==null?"grabbing":"crosshair"},children:[m.jsx("rect",{x:c.left,y:c.top,width:h,height:d,fill:"#1a1a1a",stroke:"#444"}),m.jsx("line",{x1:c.left,y1:v(1),x2:c.left+h,y2:v(1),stroke:"#666",strokeDasharray:"4,4"}),[.25,.5,.75].map(A=>m.jsx("line",{x1:x(A),y1:c.top,x2:x(A),y2:c.top+d,stroke:"#333"},`grid-x-${A}`)),[.5,1.5].map(A=>m.jsx("line",{x1:c.left,y1:v(A),x2:c.left+h,y2:v(A),stroke:"#333"},`grid-y-${A}`)),m.jsx("path",{d:T(),fill:"none",stroke:"#646cff",strokeWidth:2}),u.map((A,M)=>m.jsx("g",{children:m.jsx("circle",{cx:x(A.x),cy:v(A.y),r:o===M?8:6,fill:r===M?"#ff6b6b":"#646cff",stroke:"#fff",strokeWidth:2,style:{cursor:s?"not-allowed":"grab"},onMouseDown:_=>g(_,M),onMouseEnter:()=>a(M),onMouseLeave:()=>a(null)})},M)),b.map(A=>m.jsx("text",{x:c.left-5,y:v(A),textAnchor:"end",dominantBaseline:"middle",fill:"#999",fontSize:10,children:A},`label-y-${A}`)),m.jsx("text",{x:c.left,y:f-5,textAnchor:"start",fill:"#999",fontSize:10,children:"1"}),m.jsx("text",{x:c.left+h,y:f-5,textAnchor:"end",fill:"#999",fontSize:10,children:t}),m.jsx("text",{x:c.left+h/2,y:f-5,textAnchor:"middle",fill:"#999",fontSize:10,children:"固有値インデックス"}),m.jsx("text",{x:10,y:c.top+d/2,textAnchor:"middle",dominantBaseline:"middle",fill:"#999",fontSize:10,transform:`rotate(-90, 10, ${c.top+d/2})`,children:"フィルター値"})]}),m.jsx("div",{className:"curve-editor-hint",children:"ダブルクリック: 点の追加/削除 | ドラッグ: 点の移動"})]})}function xe({content:u,children:e}){const[t,s]=L.useState(!1),[n,r]=L.useState({}),i=L.useRef(null),o=L.useRef(null);return L.useEffect(()=>{if(t&&i.current){const a=i.current.getBoundingClientRect(),l=280,f=o.current?.offsetHeight||200,c=10;let h=a.left+a.width/2-l/2;h<c?h=c:h+l>window.innerWidth-c&&(h=window.innerWidth-l-c);let d;a.bottom+f+c>window.innerHeight?d=a.top-f-8:d=a.bottom+8,r({left:`${h}px`,top:`${d}px`})}},[t]),L.useEffect(()=>{const a=l=>{t&&i.current&&!i.current.contains(l.target)&&o.current&&!o.current.contains(l.target)&&s(!1)};return document.addEventListener("mousedown",a),()=>document.removeEventListener("mousedown",a)},[t]),m.jsxs("span",{className:"tooltip-container",children:[m.jsx("button",{ref:i,className:"tooltip-trigger",onClick:()=>s(!t),onMouseEnter:()=>s(!0),onMouseLeave:()=>s(!1),type:"button","aria-label":"ヘルプ",children:e||"?"}),t&&m.jsx("div",{ref:o,className:"tooltip-content",style:n,children:u})]})}class Vn extends Re{constructor(e){super(e)}load(e,t,s,n){const r=this,i=new Pe(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(o){try{t(r.parse(o))}catch(a){n?n(a):console.error(a),r.manager.itemError(e)}},s,n)}parse(e){function t(l){const f=new DataView(l),c=32/8*3+32/8*3*3+16/8,h=f.getUint32(80,!0);if(80+32/8+h*c===f.byteLength)return!0;const x=[115,111,108,105,100];for(let v=0;v<5;v++)if(s(x,f,v))return!1;return!0}function s(l,f,c){for(let h=0,d=l.length;h<d;h++)if(l[h]!==f.getUint8(c+h))return!1;return!0}function n(l){const f=new DataView(l),c=f.getUint32(80,!0);let h,d,x,v=!1,p,y,T,g,w;for(let S=0;S<70;S++)f.getUint32(S,!1)==1129270351&&f.getUint8(S+4)==82&&f.getUint8(S+5)==61&&(v=!0,p=new Float32Array(c*3*3),y=f.getUint8(S+6)/255,T=f.getUint8(S+7)/255,g=f.getUint8(S+8)/255,w=f.getUint8(S+9)/255);const R=84,E=50,b=new se,A=new Float32Array(c*3*3),M=new Float32Array(c*3*3),_=new G;for(let S=0;S<c;S++){const F=R+S*E,z=f.getFloat32(F,!0),ee=f.getFloat32(F+4,!0),V=f.getFloat32(F+8,!0);if(v){const j=f.getUint16(F+48,!0);(j&32768)===0?(h=(j&31)/31,d=(j>>5&31)/31,x=(j>>10&31)/31):(h=y,d=T,x=g)}for(let j=1;j<=3;j++){const Z=F+j*12,W=S*3*3+(j-1)*3;A[W]=f.getFloat32(Z,!0),A[W+1]=f.getFloat32(Z+4,!0),A[W+2]=f.getFloat32(Z+8,!0),M[W]=z,M[W+1]=ee,M[W+2]=V,v&&(_.setRGB(h,d,x,N),p[W]=_.r,p[W+1]=_.g,p[W+2]=_.b)}}return b.setAttribute("position",new ae(A,3)),b.setAttribute("normal",new ae(M,3)),v&&(b.setAttribute("color",new ae(p,3)),b.hasColors=!0,b.alpha=w),b}function r(l){const f=new se,c=/solid([\s\S]*?)endsolid/g,h=/facet([\s\S]*?)endfacet/g,d=/solid\s(.+)/;let x=0;const v=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,p=new RegExp("vertex"+v+v+v,"g"),y=new RegExp("normal"+v+v+v,"g"),T=[],g=[],w=[],R=new H;let E,b=0,A=0,M=0;for(;(E=c.exec(l))!==null;){A=M;const _=E[0],S=(E=d.exec(_))!==null?E[1]:"";for(w.push(S);(E=h.exec(_))!==null;){let ee=0,V=0;const j=E[0];for(;(E=y.exec(j))!==null;)R.x=parseFloat(E[1]),R.y=parseFloat(E[2]),R.z=parseFloat(E[3]),V++;for(;(E=p.exec(j))!==null;)T.push(parseFloat(E[1]),parseFloat(E[2]),parseFloat(E[3])),g.push(R.x,R.y,R.z),ee++,M++;V!==1&&console.error("THREE.STLLoader: Something isn't right with the normal of face number "+x),ee!==3&&console.error("THREE.STLLoader: Something isn't right with the vertices of face number "+x),x++}const F=A,z=M-A;f.userData.groupNames=w,f.addGroup(F,z,b),b++}return f.setAttribute("position",new K(T,3)),f.setAttribute("normal",new K(g,3)),f}function i(l){return typeof l!="string"?new TextDecoder().decode(l):l}function o(l){if(typeof l=="string"){const f=new Uint8Array(l.length);for(let c=0;c<l.length;c++)f[c]=l.charCodeAt(c)&255;return f.buffer||f}else return l}const a=o(e);return t(a)?n(a):r(i(e))}}const q=new G;class zn extends Re{constructor(e){super(e),this.propertyNameMapping={},this.customPropertyMapping={}}load(e,t,s,n){const r=this,i=new Pe(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(o){try{t(r.parse(o))}catch(a){n?n(a):console.error(a),r.manager.itemError(e)}},s,n)}setPropertyNameMapping(e){this.propertyNameMapping=e}setCustomPropertyNameMapping(e){this.customPropertyMapping=e}parse(e){function t(p,y=0){const T=/^ply([\s\S]*)end_header(\r\n|\r|\n)/;let g="";const w=T.exec(p);w!==null&&(g=w[1]);const R={comments:[],elements:[],headerLength:y,objInfo:""},E=g.split(/\r\n|\r|\n/);let b;function A(M,_){const S={type:M[0]};return S.type==="list"?(S.name=M[3],S.countType=M[1],S.itemType=M[2]):S.name=M[1],S.name in _&&(S.name=_[S.name]),S}for(let M=0;M<E.length;M++){let _=E[M];if(_=_.trim(),_==="")continue;const S=_.split(/\s+/),F=S.shift();switch(_=S.join(" "),F){case"format":R.format=S[0],R.version=S[1];break;case"comment":R.comments.push(_);break;case"element":b!==void 0&&R.elements.push(b),b={},b.name=S[0],b.count=parseInt(S[1]),b.properties=[];break;case"property":b.properties.push(A(S,v.propertyNameMapping));break;case"obj_info":R.objInfo=_;break;default:console.log("unhandled",F,S)}}return b!==void 0&&R.elements.push(b),R}function s(p,y){switch(y){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(p);case"float":case"double":case"float32":case"float64":return parseFloat(p)}}function n(p,y){const T={};for(let g=0;g<p.length;g++){if(y.empty())return null;if(p[g].type==="list"){const w=[],R=s(y.next(),p[g].countType);for(let E=0;E<R;E++){if(y.empty())return null;w.push(s(y.next(),p[g].itemType))}T[p[g].name]=w}else T[p[g].name]=s(y.next(),p[g].type)}return T}function r(){const p={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[],faceVertexColors:[]};for(const y of Object.keys(v.customPropertyMapping))p[y]=[];return p}function i(p){const y=p.map(g=>g.name);function T(g){for(let w=0,R=g.length;w<R;w++){const E=g[w];if(y.includes(E))return E}return null}return{attrX:T(["x","px","posx"])||"x",attrY:T(["y","py","posy"])||"y",attrZ:T(["z","pz","posz"])||"z",attrNX:T(["nx","normalx"]),attrNY:T(["ny","normaly"]),attrNZ:T(["nz","normalz"]),attrS:T(["s","u","texture_u","tx"]),attrT:T(["t","v","texture_v","ty"]),attrR:T(["red","diffuse_red","r","diffuse_r"]),attrG:T(["green","diffuse_green","g","diffuse_g"]),attrB:T(["blue","diffuse_blue","b","diffuse_b"])}}function o(p,y){const T=r(),g=/end_header\s+(\S[\s\S]*\S|\S)\s*$/;let w,R;(R=g.exec(p))!==null?w=R[1].split(/\s+/):w=[];const E=new Xn(w);e:for(let b=0;b<y.elements.length;b++){const A=y.elements[b],M=i(A.properties);for(let _=0;_<A.count;_++){const S=n(A.properties,E);if(!S)break e;l(T,A.name,S,M)}}return a(T)}function a(p){let y=new se;p.indices.length>0&&y.setIndex(p.indices),y.setAttribute("position",new K(p.vertices,3)),p.normals.length>0&&y.setAttribute("normal",new K(p.normals,3)),p.uvs.length>0&&y.setAttribute("uv",new K(p.uvs,2)),p.colors.length>0&&y.setAttribute("color",new K(p.colors,3)),(p.faceVertexUvs.length>0||p.faceVertexColors.length>0)&&(y=y.toNonIndexed(),p.faceVertexUvs.length>0&&y.setAttribute("uv",new K(p.faceVertexUvs,2)),p.faceVertexColors.length>0&&y.setAttribute("color",new K(p.faceVertexColors,3)));for(const T of Object.keys(v.customPropertyMapping))p[T].length>0&&y.setAttribute(T,new K(p[T],v.customPropertyMapping[T].length));return y.computeBoundingSphere(),y}function l(p,y,T,g){if(y==="vertex"){p.vertices.push(T[g.attrX],T[g.attrY],T[g.attrZ]),g.attrNX!==null&&g.attrNY!==null&&g.attrNZ!==null&&p.normals.push(T[g.attrNX],T[g.attrNY],T[g.attrNZ]),g.attrS!==null&&g.attrT!==null&&p.uvs.push(T[g.attrS],T[g.attrT]),g.attrR!==null&&g.attrG!==null&&g.attrB!==null&&(q.setRGB(T[g.attrR]/255,T[g.attrG]/255,T[g.attrB]/255,N),p.colors.push(q.r,q.g,q.b));for(const w of Object.keys(v.customPropertyMapping))for(const R of v.customPropertyMapping[w])p[w].push(T[R])}else if(y==="face"){const w=T.vertex_indices||T.vertex_index,R=T.texcoord;w.length===3?(p.indices.push(w[0],w[1],w[2]),R&&R.length===6&&(p.faceVertexUvs.push(R[0],R[1]),p.faceVertexUvs.push(R[2],R[3]),p.faceVertexUvs.push(R[4],R[5]))):w.length===4&&(p.indices.push(w[0],w[1],w[3]),p.indices.push(w[1],w[2],w[3])),g.attrR!==null&&g.attrG!==null&&g.attrB!==null&&(q.setRGB(T[g.attrR]/255,T[g.attrG]/255,T[g.attrB]/255,N),p.faceVertexColors.push(q.r,q.g,q.b),p.faceVertexColors.push(q.r,q.g,q.b),p.faceVertexColors.push(q.r,q.g,q.b))}}function f(p,y){const T={};let g=0;for(let w=0;w<y.length;w++){const R=y[w],E=R.valueReader;if(R.type==="list"){const b=[],A=R.countReader.read(p+g);g+=R.countReader.size;for(let M=0;M<A;M++)b.push(E.read(p+g)),g+=E.size;T[R.name]=b}else T[R.name]=E.read(p+g),g+=E.size}return[T,g]}function c(p,y,T){function g(w,R,E){switch(R){case"int8":case"char":return{read:b=>w.getInt8(b),size:1};case"uint8":case"uchar":return{read:b=>w.getUint8(b),size:1};case"int16":case"short":return{read:b=>w.getInt16(b,E),size:2};case"uint16":case"ushort":return{read:b=>w.getUint16(b,E),size:2};case"int32":case"int":return{read:b=>w.getInt32(b,E),size:4};case"uint32":case"uint":return{read:b=>w.getUint32(b,E),size:4};case"float32":case"float":return{read:b=>w.getFloat32(b,E),size:4};case"float64":case"double":return{read:b=>w.getFloat64(b,E),size:8}}}for(let w=0,R=p.length;w<R;w++){const E=p[w];E.type==="list"?(E.countReader=g(y,E.countType,T),E.valueReader=g(y,E.itemType,T)):E.valueReader=g(y,E.type,T)}}function h(p,y){const T=r(),g=y.format==="binary_little_endian",w=new DataView(p,y.headerLength);let R,E=0;for(let b=0;b<y.elements.length;b++){const A=y.elements[b],M=A.properties,_=i(M);c(M,w,g);for(let S=0;S<A.count;S++){R=f(E,M),E+=R[1];const F=R[0];l(T,A.name,F,_)}}return a(T)}function d(p){let y=0,T=!0,g="";const w=[],R=new TextDecoder().decode(p.subarray(0,5)),E=/^ply\r\n/.test(R);do{const b=String.fromCharCode(p[y++]);b!==`
`&&b!=="\r"?g+=b:(g==="end_header"&&(T=!1),g!==""&&(w.push(g),g=""))}while(T&&y<p.length);return E===!0&&y++,{headerText:w.join("\r")+"\r",headerLength:y}}let x;const v=this;if(e instanceof ArrayBuffer){const p=new Uint8Array(e),{headerText:y,headerLength:T}=d(p),g=t(y,T);if(g.format==="ascii"){const w=new TextDecoder().decode(p);x=o(w,g)}else x=h(e,g)}else x=o(e,t(e));return x}}class Xn{constructor(e){this.arr=e,this.i=0}empty(){return this.i>=this.arr.length}next(){return this.arr[this.i++]}}function mt(u,e){if(e===on)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),u;if(e===qe||e===Et){let t=u.getIndex();if(t===null){const i=[],o=u.getAttribute("position");if(o!==void 0){for(let a=0;a<o.count;a++)i.push(a);u.setIndex(i),t=u.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),u}const s=t.count-2,n=[];if(e===qe)for(let i=1;i<=s;i++)n.push(t.getX(0)),n.push(t.getX(i)),n.push(t.getX(i+1));else for(let i=0;i<s;i++)i%2===0?(n.push(t.getX(i)),n.push(t.getX(i+1)),n.push(t.getX(i+2))):(n.push(t.getX(i+2)),n.push(t.getX(i+1)),n.push(t.getX(i)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=u.clone();return r.setIndex(n),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),u}class Kn extends Re{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Zn(t)}),this.register(function(t){return new Jn(t)}),this.register(function(t){return new as(t)}),this.register(function(t){return new cs(t)}),this.register(function(t){return new ls(t)}),this.register(function(t){return new es(t)}),this.register(function(t){return new ts(t)}),this.register(function(t){return new ns(t)}),this.register(function(t){return new ss(t)}),this.register(function(t){return new $n(t)}),this.register(function(t){return new rs(t)}),this.register(function(t){return new Qn(t)}),this.register(function(t){return new os(t)}),this.register(function(t){return new is(t)}),this.register(function(t){return new Wn(t)}),this.register(function(t){return new us(t)}),this.register(function(t){return new fs(t)})}load(e,t,s,n){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const l=we.extractUrlBase(e);i=we.resolveURL(l,this.path)}else i=we.extractUrlBase(e);this.manager.itemStart(e);const o=function(l){n?n(l):console.error(l),r.manager.itemError(e),r.manager.itemEnd(e)},a=new Pe(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{r.parse(l,i,function(f){t(f),r.manager.itemEnd(e)},o)}catch(f){o(f)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const i={},o={},a=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(a.decode(new Uint8Array(e,0,4))===Bt){try{i[C.KHR_BINARY_GLTF]=new hs(e)}catch(c){n&&n(c);return}r=JSON.parse(i[C.KHR_BINARY_GLTF].content)}else r=JSON.parse(a.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Ss(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let f=0;f<this.pluginCallbacks.length;f++){const c=this.pluginCallbacks[f](l);c.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[c.name]=c,i[c.name]=!0}if(r.extensionsUsed)for(let f=0;f<r.extensionsUsed.length;++f){const c=r.extensionsUsed[f],h=r.extensionsRequired||[];switch(c){case C.KHR_MATERIALS_UNLIT:i[c]=new qn;break;case C.KHR_DRACO_MESH_COMPRESSION:i[c]=new ps(r,this.dracoLoader);break;case C.KHR_TEXTURE_TRANSFORM:i[c]=new ds;break;case C.KHR_MESH_QUANTIZATION:i[c]=new ms;break;default:h.indexOf(c)>=0&&o[c]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+c+'".')}}l.setExtensions(i),l.setPlugins(o),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function Yn(){let u={};return{get:function(e){return u[e]},add:function(e,t){u[e]=t},remove:function(e){delete u[e]},removeAll:function(){u={}}}}const C={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Wn{constructor(e){this.parser=e,this.name=C.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,a=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let l;const f=new G(16777215);a.color!==void 0&&f.setRGB(a.color[0],a.color[1],a.color[2],le);const c=a.range!==void 0?a.range:0;switch(a.type){case"directional":l=new bt(f),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new $e(f),l.distance=c;break;case"spot":l=new St(f),l.distance=c,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,l.angle=a.spot.outerConeAngle,l.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return l.position.set(0,0,0),ie(l,a),a.intensity!==void 0&&(l.intensity=a.intensity),l.name=t.createUniqueName(a.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(a){return s._getNodeRef(t.cache,o,a)})}}class qn{constructor(){this.name=C.KHR_MATERIALS_UNLIT}getMaterialType(){return be}extendParams(e,t,s){const n=[];e.color=new G(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],le),e.opacity=i[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,N))}return Promise.all(n)}}class $n{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class Zn{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const o=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new at(o,o)}return Promise.all(r)}}class Jn{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class Qn{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class es{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new G(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=n.extensions[this.name];if(i.sheenColorFactor!==void 0){const o=i.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],le)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",i.sheenColorTexture,N)),i.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class ts{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class ns{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const o=i.attenuationColor||[1,1,1];return t.attenuationColor=new G().setRGB(o[0],o[1],o[2],le),Promise.all(r)}}class ss{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class rs{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",i.specularTexture));const o=i.specularColorFactor||[1,1,1];return t.specularColor=new G().setRGB(o[0],o[1],o[2],le),i.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",i.specularColorTexture,N)),Promise.all(r)}}class is{constructor(e){this.parser=e,this.name=C.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(s.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class os{constructor(e){this.parser=e,this.name=C.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class as{constructor(e){this.parser=e,this.name=C.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class cs{constructor(e){this.parser=e,this.name=C.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=n.images[i.source];let a=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(a=l)}return s.loadTextureImage(e,i.source,a)}}class ls{constructor(e){this.parser=e,this.name=C.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=n.images[i.source];let a=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(a=l)}return s.loadTextureImage(e,i.source,a)}}class us{constructor(e){this.name=C.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(o){const a=n.byteOffset||0,l=n.byteLength||0,f=n.count,c=n.byteStride,h=new Uint8Array(o,a,l);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(f,c,h,n.mode,n.filter).then(function(d){return d.buffer}):i.ready.then(function(){const d=new ArrayBuffer(f*c);return i.decodeGltfBuffer(new Uint8Array(d),f,c,h,n.mode,n.filter),d})})}else return null}}class fs{constructor(e){this.name=C.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==J.TRIANGLES&&l.mode!==J.TRIANGLE_STRIP&&l.mode!==J.TRIANGLE_FAN&&l.mode!==void 0)return null;const i=s.extensions[this.name].attributes,o=[],a={};for(const l in i)o.push(this.parser.getDependency("accessor",i[l]).then(f=>(a[l]=f,a[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const f=l.pop(),c=f.isGroup?f.children:[f],h=l[0].count,d=[];for(const x of c){const v=new D,p=new H,y=new re,T=new H(1,1,1),g=new an(x.geometry,x.material,h);for(let w=0;w<h;w++)a.TRANSLATION&&p.fromBufferAttribute(a.TRANSLATION,w),a.ROTATION&&y.fromBufferAttribute(a.ROTATION,w),a.SCALE&&T.fromBufferAttribute(a.SCALE,w),g.setMatrixAt(w,v.compose(p,y,T));for(const w in a)if(w==="_COLOR_0"){const R=a[w];g.instanceColor=new cn(R.array,R.itemSize,R.normalized)}else w!=="TRANSLATION"&&w!=="ROTATION"&&w!=="SCALE"&&x.geometry.setAttribute(w,a[w]);ve.prototype.copy.call(g,x),this.parser.assignFinalMaterial(g),d.push(g)}return f.isGroup?(f.clear(),f.add(...d),f):d[0]}))}}const Bt="glTF",Se=12,gt={JSON:1313821514,BIN:5130562};class hs{constructor(e){this.name=C.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Se),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Bt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Se,r=new DataView(e,Se);let i=0;for(;i<n;){const o=r.getUint32(i,!0);i+=4;const a=r.getUint32(i,!0);if(i+=4,a===gt.JSON){const l=new Uint8Array(e,Se+i,o);this.content=s.decode(l)}else if(a===gt.BIN){const l=Se+i;this.body=e.slice(l,l+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ps{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=C.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,o={},a={},l={};for(const f in i){const c=st[f]||f.toLowerCase();o[c]=i[f]}for(const f in e.attributes){const c=st[f]||f.toLowerCase();if(i[f]!==void 0){const h=s.accessors[e.attributes[f]],d=Ae[h.componentType];l[c]=d.name,a[c]=h.normalized===!0}}return t.getDependency("bufferView",r).then(function(f){return new Promise(function(c,h){n.decodeDracoFile(f,function(d){for(const x in d.attributes){const v=d.attributes[x],p=a[x];p!==void 0&&(v.normalized=p)}c(d)},o,l,le,h)})})}}class ds{constructor(){this.name=C.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ms{constructor(){this.name=C.KHR_MESH_QUANTIZATION}}class Ut extends Rn{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let i=0;i!==n;i++)t[i]=s[r+i];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=o*2,l=o*3,f=n-t,c=(s-t)/f,h=c*c,d=h*c,x=e*l,v=x-l,p=-2*d+3*h,y=d-h,T=1-p,g=y-h+c;for(let w=0;w!==o;w++){const R=i[v+w+o],E=i[v+w+a]*f,b=i[x+w+o],A=i[x+w]*f;r[w]=T*R+g*E+p*b+y*A}return r}}const gs=new re;class xs extends Ut{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return gs.fromArray(r).normalize().toArray(r),r}}const J={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Ae={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},xt={9728:Lt,9729:Ze,9984:pn,9985:hn,9986:fn,9987:Mt},yt={33071:Je,33648:dn,10497:Le},Ge={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},st={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ue={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ys={CUBICSPLINE:void 0,LINEAR:jt,STEP:Tn},Ve={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function vs(u){return u.DefaultMaterial===void 0&&(u.DefaultMaterial=new Ct({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:An})),u.DefaultMaterial}function me(u,e,t){for(const s in t.extensions)u[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function ie(u,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(u.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Ts(u,e,t){let s=!1,n=!1,r=!1;for(let l=0,f=e.length;l<f;l++){const c=e[l];if(c.POSITION!==void 0&&(s=!0),c.NORMAL!==void 0&&(n=!0),c.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(u);const i=[],o=[],a=[];for(let l=0,f=e.length;l<f;l++){const c=e[l];if(s){const h=c.POSITION!==void 0?t.getDependency("accessor",c.POSITION):u.attributes.position;i.push(h)}if(n){const h=c.NORMAL!==void 0?t.getDependency("accessor",c.NORMAL):u.attributes.normal;o.push(h)}if(r){const h=c.COLOR_0!==void 0?t.getDependency("accessor",c.COLOR_0):u.attributes.color;a.push(h)}}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a)]).then(function(l){const f=l[0],c=l[1],h=l[2];return s&&(u.morphAttributes.position=f),n&&(u.morphAttributes.normal=c),r&&(u.morphAttributes.color=h),u.morphTargetsRelative=!0,u})}function ws(u,e){if(u.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)u.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(u.morphTargetInfluences.length===t.length){u.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)u.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function As(u){let e;const t=u.extensions&&u.extensions[C.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+ze(t.attributes):e=u.indices+":"+ze(u.attributes)+":"+u.mode,u.targets!==void 0)for(let s=0,n=u.targets.length;s<n;s++)e+=":"+ze(u.targets[s]);return e}function ze(u){let e="";const t=Object.keys(u).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+u[t[s]]+";";return e}function rt(u){switch(u){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Rs(u){return u.search(/\.jpe?g($|\?)/i)>0||u.search(/^data\:image\/jpeg/)===0?"image/jpeg":u.search(/\.webp($|\?)/i)>0||u.search(/^data\:image\/webp/)===0?"image/webp":u.search(/\.ktx2($|\?)/i)>0||u.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const Es=new D;class Ss{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Yn,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,r=!1,i=-1;if(typeof navigator<"u"){const o=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(o)===!0;const a=o.match(/Version\/(\d+)/);n=s&&a?parseInt(a[1],10):-1,r=o.indexOf("Firefox")>-1,i=r?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||r&&i<98?this.textureLoader=new _t(this.options.manager):this.textureLoader=new ln(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Pe(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(i){const o={scene:i[0][n.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:n.asset,parser:s,userData:{}};return me(r,o,n),ie(o,n),Promise.all(s._invokeAll(function(a){return a.afterRoot&&a.afterRoot(o)})).then(function(){for(const a of o.scenes)a.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let o=0,a=i.length;o<a;o++)e[i[o]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const i=e[n];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(s[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(i,o)=>{const a=this.associations.get(i);a!=null&&this.associations.set(o,a);for(const[l,f]of i.children.entries())r(f,o.children[l])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[C.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,i){s.load(we.resolveURL(t.uri,n.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const i=Ge[n.type],o=Ae[n.componentType],a=n.normalized===!0,l=new o(n.count*i);return Promise.resolve(new ae(l,i,a))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(i){const o=i[0],a=Ge[n.type],l=Ae[n.componentType],f=l.BYTES_PER_ELEMENT,c=f*a,h=n.byteOffset||0,d=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,x=n.normalized===!0;let v,p;if(d&&d!==c){const y=Math.floor(h/d),T="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+y+":"+n.count;let g=t.cache.get(T);g||(v=new l(o,y*d,n.count*d/f),g=new un(v,d/f),t.cache.add(T,g)),p=new wn(g,a,h%d/f,x)}else o===null?v=new l(n.count*a):v=new l(o,h,n.count*a),p=new ae(v,a,x);if(n.sparse!==void 0){const y=Ge.SCALAR,T=Ae[n.sparse.indices.componentType],g=n.sparse.indices.byteOffset||0,w=n.sparse.values.byteOffset||0,R=new T(i[1],g,n.sparse.count*y),E=new l(i[2],w,n.sparse.count*a);o!==null&&(p=new ae(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let b=0,A=R.length;b<A;b++){const M=R[b];if(p.setX(M,E[b*a]),a>=2&&p.setY(M,E[b*a+1]),a>=3&&p.setZ(M,E[b*a+2]),a>=4&&p.setW(M,E[b*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=x}return p})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,i=t.images[r];let o=this.textureLoader;if(i.uri){const a=s.manager.getHandler(i.uri);a!==null&&(o=a)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,s){const n=this,r=this.json,i=r.textures[e],o=r.images[t],a=(o.uri||o.bufferView)+":"+i.sampler;if(this.textureCache[a])return this.textureCache[a];const l=this.loadImageSource(t,s).then(function(f){f.flipY=!1,f.name=i.name||o.name||"",f.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(f.name=o.uri);const h=(r.samplers||{})[i.sampler]||{};return f.magFilter=xt[h.magFilter]||Ze,f.minFilter=xt[h.minFilter]||Mt,f.wrapS=yt[h.wrapS]||Le,f.wrapT=yt[h.wrapT]||Le,f.generateMipmaps=!f.isCompressedTexture&&f.minFilter!==Lt&&f.minFilter!==Ze,n.associations.set(f,{textures:e}),f}).catch(function(){return null});return this.textureCache[a]=l,l}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(c=>c.clone());const i=n.images[e],o=self.URL||self.webkitURL;let a=i.uri||"",l=!1;if(i.bufferView!==void 0)a=s.getDependency("bufferView",i.bufferView).then(function(c){l=!0;const h=new Blob([c],{type:i.mimeType});return a=o.createObjectURL(h),a});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(a).then(function(c){return new Promise(function(h,d){let x=h;t.isImageBitmapLoader===!0&&(x=function(v){const p=new et(v);p.needsUpdate=!0,h(p)}),t.load(we.resolveURL(c,r.path),x,void 0,d)})}).then(function(c){return l===!0&&o.revokeObjectURL(a),ie(c,i),c.userData.mimeType=i.mimeType||Rs(i.uri),c}).catch(function(c){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),c});return this.sourceCache[e]=f,f}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(i){if(!i)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(i=i.clone(),i.channel=s.texCoord),r.extensions[C.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[C.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=r.associations.get(i);i=r.extensions[C.KHR_TEXTURE_TRANSFORM].extendTexture(i,o),r.associations.set(i,a)}}return n!==void 0&&(i.colorSpace=n),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new mn,He.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,a.sizeAttenuation=!1,this.cache.add(o,a)),s=a}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new It,He.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,this.cache.add(o,a)),s=a}if(n||r||i){let o="ClonedMaterial:"+s.uuid+":";n&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),i&&(o+="flat-shading:");let a=this.cache.get(o);a||(a=s.clone(),r&&(a.vertexColors=!0),i&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(o,a),this.associations.set(a,this.associations.get(s))),s=a}e.material=s}getMaterialType(){return Ct}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let i;const o={},a=r.extensions||{},l=[];if(a[C.KHR_MATERIALS_UNLIT]){const c=n[C.KHR_MATERIALS_UNLIT];i=c.getMaterialType(),l.push(c.extendParams(o,r,t))}else{const c=r.pbrMetallicRoughness||{};if(o.color=new G(1,1,1),o.opacity=1,Array.isArray(c.baseColorFactor)){const h=c.baseColorFactor;o.color.setRGB(h[0],h[1],h[2],le),o.opacity=h[3]}c.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",c.baseColorTexture,N)),o.metalness=c.metallicFactor!==void 0?c.metallicFactor:1,o.roughness=c.roughnessFactor!==void 0?c.roughnessFactor:1,c.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",c.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",c.metallicRoughnessTexture))),i=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,o)})))}r.doubleSided===!0&&(o.side=ot);const f=r.alphaMode||Ve.OPAQUE;if(f===Ve.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,f===Ve.MASK&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==be&&(l.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new at(1,1),r.normalTexture.scale!==void 0)){const c=r.normalTexture.scale;o.normalScale.set(c,c)}if(r.occlusionTexture!==void 0&&i!==be&&(l.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==be){const c=r.emissiveFactor;o.emissive=new G().setRGB(c[0],c[1],c[2],le)}return r.emissiveTexture!==void 0&&i!==be&&l.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,N)),Promise.all(l).then(function(){const c=new i(o);return r.name&&(c.name=r.name),ie(c,r),t.associations.set(c,{materials:e}),r.extensions&&me(n,c,r),c})}createUniqueName(e){const t=Ie.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(o){return s[C.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(a){return vt(a,o,t)})}const i=[];for(let o=0,a=e.length;o<a;o++){const l=e[o],f=As(l),c=n[f];if(c)i.push(c.promise);else{let h;l.extensions&&l.extensions[C.KHR_DRACO_MESH_COMPRESSION]?h=r(l):h=vt(new se,l,t),n[f]={primitive:l,promise:h},i.push(h)}}return Promise.all(i)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],i=r.primitives,o=[];for(let a=0,l=i.length;a<l;a++){const f=i[a].material===void 0?vs(this.cache):this.getDependency("material",i[a].material);o.push(f)}return o.push(t.loadGeometries(i)),Promise.all(o).then(function(a){const l=a.slice(0,a.length-1),f=a[a.length-1],c=[];for(let d=0,x=f.length;d<x;d++){const v=f[d],p=i[d];let y;const T=l[d];if(p.mode===J.TRIANGLES||p.mode===J.TRIANGLE_STRIP||p.mode===J.TRIANGLE_FAN||p.mode===void 0)y=r.isSkinnedMesh===!0?new Ft(v,T):new ct(v,T),y.isSkinnedMesh===!0&&y.normalizeSkinWeights(),p.mode===J.TRIANGLE_STRIP?y.geometry=mt(y.geometry,Et):p.mode===J.TRIANGLE_FAN&&(y.geometry=mt(y.geometry,qe));else if(p.mode===J.LINES)y=new gn(v,T);else if(p.mode===J.LINE_STRIP)y=new Pt(v,T);else if(p.mode===J.LINE_LOOP)y=new xn(v,T);else if(p.mode===J.POINTS)y=new yn(v,T);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+p.mode);Object.keys(y.geometry.morphAttributes).length>0&&ws(y,r),y.name=t.createUniqueName(r.name||"mesh_"+e),ie(y,r),p.extensions&&me(n,y,p),t.assignFinalMaterial(y),c.push(y)}for(let d=0,x=c.length;d<x;d++)t.associations.set(c[d],{meshes:e,primitives:d});if(c.length===1)return r.extensions&&me(n,c[0],r),c[0];const h=new _e;r.extensions&&me(n,h,r),t.associations.set(h,{meshes:e});for(let d=0,x=c.length;d<x;d++)h.add(c[d]);return h})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Dt(X.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new vn(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),ie(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),i=n,o=[],a=[];for(let l=0,f=i.length;l<f;l++){const c=i[l];if(c){o.push(c);const h=new D;r!==null&&h.fromArray(r.array,l*16),a.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new kt(o,a)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,i=[],o=[],a=[],l=[],f=[];for(let c=0,h=n.channels.length;c<h;c++){const d=n.channels[c],x=n.samplers[d.sampler],v=d.target,p=v.node,y=n.parameters!==void 0?n.parameters[x.input]:x.input,T=n.parameters!==void 0?n.parameters[x.output]:x.output;v.node!==void 0&&(i.push(this.getDependency("node",p)),o.push(this.getDependency("accessor",y)),a.push(this.getDependency("accessor",T)),l.push(x),f.push(v))}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(f)]).then(function(c){const h=c[0],d=c[1],x=c[2],v=c[3],p=c[4],y=[];for(let g=0,w=h.length;g<w;g++){const R=h[g],E=d[g],b=x[g],A=v[g],M=p[g];if(R===void 0)continue;R.updateMatrix&&R.updateMatrix();const _=s._createAnimationTracks(R,E,b,A,M);if(_)for(let S=0;S<_.length;S++)y.push(_[S])}const T=new Ot(r,void 0,y);return ie(T,n),T})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const i=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&i.traverse(function(o){if(o.isMesh)for(let a=0,l=n.weights.length;a<l;a++)o.morphTargetInfluences[a]=n.weights[a]}),i})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),i=[],o=n.children||[];for(let l=0,f=o.length;l<f;l++)i.push(s.getDependency("node",o[l]));const a=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),a]).then(function(l){const f=l[0],c=l[1],h=l[2];h!==null&&f.traverse(function(d){d.isSkinnedMesh&&d.bind(h,Es)});for(let d=0,x=c.length;d<x;d++)f.add(c[d]);return f})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?n.createUniqueName(r.name):"",o=[],a=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return a&&o.push(a),r.camera!==void 0&&o.push(n.getDependency("camera",r.camera).then(function(l){return n._getNodeRef(n.cameraCache,r.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),this.nodeCache[e]=Promise.all(o).then(function(l){let f;if(r.isBone===!0?f=new Qe:l.length>1?f=new _e:l.length===1?f=l[0]:f=new ve,f!==l[0])for(let c=0,h=l.length;c<h;c++)f.add(l[c]);if(r.name&&(f.userData.name=r.name,f.name=i),ie(f,r),r.extensions&&me(s,f,r),r.matrix!==void 0){const c=new D;c.fromArray(r.matrix),f.applyMatrix4(c)}else r.translation!==void 0&&f.position.fromArray(r.translation),r.rotation!==void 0&&f.quaternion.fromArray(r.rotation),r.scale!==void 0&&f.scale.fromArray(r.scale);if(!n.associations.has(f))n.associations.set(f,{});else if(r.mesh!==void 0&&n.meshCache.refs[r.mesh]>1){const c=n.associations.get(f);n.associations.set(f,{...c})}return n.associations.get(f).nodes=e,f}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new _e;s.name&&(r.name=n.createUniqueName(s.name)),ie(r,s),s.extensions&&me(t,r,s);const i=s.nodes||[],o=[];for(let a=0,l=i.length;a<l;a++)o.push(n.getDependency("node",i[a]));return Promise.all(o).then(function(a){for(let f=0,c=a.length;f<c;f++)r.add(a[f]);const l=f=>{const c=new Map;for(const[h,d]of n.associations)(h instanceof He||h instanceof et)&&c.set(h,d);return f.traverse(h=>{const d=n.associations.get(h);d!=null&&c.set(h,d)}),c};return n.associations=l(r),r})}_createAnimationTracks(e,t,s,n,r){const i=[],o=e.name?e.name:e.uuid,a=[];ue[r.path]===ue.weights?e.traverse(function(h){h.morphTargetInfluences&&a.push(h.name?h.name:h.uuid)}):a.push(o);let l;switch(ue[r.path]){case ue.weights:l=nt;break;case ue.rotation:l=Ne;break;case ue.translation:case ue.scale:l=tt;break;default:switch(s.itemSize){case 1:l=nt;break;case 2:case 3:default:l=tt;break}break}const f=n.interpolation!==void 0?ys[n.interpolation]:jt,c=this._getArrayFromAccessor(s);for(let h=0,d=a.length;h<d;h++){const x=new l(a[h]+"."+ue[r.path],t.array,c,f);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(x),i.push(x)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=rt(t.constructor),n=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)n[r]=t[r]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof Ne?xs:Ut;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function bs(u,e,t){const s=e.attributes,n=new En;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],a=o.min,l=o.max;if(a!==void 0&&l!==void 0){if(n.set(new H(a[0],a[1],a[2]),new H(l[0],l[1],l[2])),o.normalized){const f=rt(Ae[o.componentType]);n.min.multiplyScalar(f),n.max.multiplyScalar(f)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const o=new H,a=new H;for(let l=0,f=r.length;l<f;l++){const c=r[l];if(c.POSITION!==void 0){const h=t.json.accessors[c.POSITION],d=h.min,x=h.max;if(d!==void 0&&x!==void 0){if(a.setX(Math.max(Math.abs(d[0]),Math.abs(x[0]))),a.setY(Math.max(Math.abs(d[1]),Math.abs(x[1]))),a.setZ(Math.max(Math.abs(d[2]),Math.abs(x[2]))),h.normalized){const v=rt(Ae[h.componentType]);a.multiplyScalar(v)}o.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}u.boundingBox=n;const i=new Sn;n.getCenter(i.center),i.radius=n.min.distanceTo(n.max)/2,u.boundingSphere=i}function vt(u,e,t){const s=e.attributes,n=[];function r(i,o){return t.getDependency("accessor",i).then(function(a){u.setAttribute(o,a)})}for(const i in s){const o=st[i]||i.toLowerCase();o in u.attributes||n.push(r(s[i],o))}if(e.indices!==void 0&&!u.index){const i=t.getDependency("accessor",e.indices).then(function(o){u.setIndex(o)});n.push(i)}return oe.workingColorSpace!==le&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${oe.workingColorSpace}" not supported.`),ie(u,e),bs(u,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Ts(u,e.targets,t):u})}var Q=Uint8Array,Te=Uint16Array,_s=Int32Array,Ht=new Q([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Gt=new Q([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ms=new Q([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Vt=function(u,e){for(var t=new Te(31),s=0;s<31;++s)t[s]=e+=1<<u[s-1];for(var n=new _s(t[30]),s=1;s<30;++s)for(var r=t[s];r<t[s+1];++r)n[r]=r-t[s]<<5|s;return{b:t,r:n}},zt=Vt(Ht,2),Xt=zt.b,Ls=zt.r;Xt[28]=258,Ls[258]=28;var Is=Vt(Gt,0),Cs=Is.b,it=new Te(32768);for(var k=0;k<32768;++k){var fe=(k&43690)>>1|(k&21845)<<1;fe=(fe&52428)>>2|(fe&13107)<<2,fe=(fe&61680)>>4|(fe&3855)<<4,it[k]=((fe&65280)>>8|(fe&255)<<8)>>1}var Me=(function(u,e,t){for(var s=u.length,n=0,r=new Te(e);n<s;++n)u[n]&&++r[u[n]-1];var i=new Te(e);for(n=1;n<e;++n)i[n]=i[n-1]+r[n-1]<<1;var o;if(t){o=new Te(1<<e);var a=15-e;for(n=0;n<s;++n)if(u[n])for(var l=n<<4|u[n],f=e-u[n],c=i[u[n]-1]++<<f,h=c|(1<<f)-1;c<=h;++c)o[it[c]>>a]=l}else for(o=new Te(s),n=0;n<s;++n)u[n]&&(o[n]=it[i[u[n]-1]++]>>15-u[n]);return o}),De=new Q(288);for(var k=0;k<144;++k)De[k]=8;for(var k=144;k<256;++k)De[k]=9;for(var k=256;k<280;++k)De[k]=7;for(var k=280;k<288;++k)De[k]=8;var Kt=new Q(32);for(var k=0;k<32;++k)Kt[k]=5;var Fs=Me(De,9,1),Ps=Me(Kt,5,1),Xe=function(u){for(var e=u[0],t=1;t<u.length;++t)u[t]>e&&(e=u[t]);return e},te=function(u,e,t){var s=e/8|0;return(u[s]|u[s+1]<<8)>>(e&7)&t},Ke=function(u,e){var t=e/8|0;return(u[t]|u[t+1]<<8|u[t+2]<<16)>>(e&7)},Ds=function(u){return(u+7)/8|0},ks=function(u,e,t){return(t==null||t>u.length)&&(t=u.length),new Q(u.subarray(e,t))},Os=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],ne=function(u,e,t){var s=new Error(e||Os[u]);if(s.code=u,Error.captureStackTrace&&Error.captureStackTrace(s,ne),!t)throw s;return s},js=function(u,e,t,s){var n=u.length,r=0;if(!n||e.f&&!e.l)return t||new Q(0);var i=!t,o=i||e.i!=2,a=e.i;i&&(t=new Q(n*3));var l=function(ft){var ht=t.length;if(ft>ht){var pt=new Q(Math.max(ht*2,ft));pt.set(t),t=pt}},f=e.f||0,c=e.p||0,h=e.b||0,d=e.l,x=e.d,v=e.m,p=e.n,y=n*8;do{if(!d){f=te(u,c,1);var T=te(u,c+1,3);if(c+=3,T)if(T==1)d=Fs,x=Ps,v=9,p=5;else if(T==2){var E=te(u,c,31)+257,b=te(u,c+10,15)+4,A=E+te(u,c+5,31)+1;c+=14;for(var M=new Q(A),_=new Q(19),S=0;S<b;++S)_[Ms[S]]=te(u,c+S*3,7);c+=b*3;for(var F=Xe(_),z=(1<<F)-1,ee=Me(_,F,1),S=0;S<A;){var V=ee[te(u,c,z)];c+=V&15;var g=V>>4;if(g<16)M[S++]=g;else{var j=0,Z=0;for(g==16?(Z=3+te(u,c,3),c+=2,j=M[S-1]):g==17?(Z=3+te(u,c,7),c+=3):g==18&&(Z=11+te(u,c,127),c+=7);Z--;)M[S++]=j}}var W=M.subarray(0,E),$=M.subarray(E);v=Xe(W),p=Xe($),d=Me(W,v,1),x=Me($,p,1)}else ne(1);else{var g=Ds(c)+4,w=u[g-4]|u[g-3]<<8,R=g+w;if(R>n){a&&ne(0);break}o&&l(h+w),t.set(u.subarray(g,R),h),e.b=h+=w,e.p=c=R*8,e.f=f;continue}if(c>y){a&&ne(0);break}}o&&l(h+131072);for(var Ue=(1<<v)-1,P=(1<<p)-1,O=c;;O=c){var j=d[Ke(u,c)&Ue],U=j>>4;if(c+=j&15,c>y){a&&ne(0);break}if(j||ne(2),U<256)t[h++]=U;else if(U==256){O=c,d=null;break}else{var he=U-254;if(U>264){var S=U-257,pe=Ht[S];he=te(u,c,(1<<pe)-1)+Xt[S],c+=pe}var Ee=x[Ke(u,c)&P],de=Ee>>4;Ee||ne(3),c+=Ee&15;var $=Cs[de];if(de>3){var pe=Gt[de];$+=Ke(u,c)&(1<<pe)-1,c+=pe}if(c>y){a&&ne(0);break}o&&l(h+131072);var ke=h+he;if(h<$){var ut=r-$,rn=Math.min($,ke);for(ut+h<0&&ne(3);h<rn;++h)t[h]=s[ut+h]}for(;h<ke;++h)t[h]=t[h-$]}}e.l=d,e.p=O,e.b=h,e.f=f,d&&(f=1,e.m=v,e.d=x,e.n=p)}while(!f);return h!=t.length&&i?ks(t,0,h):t.subarray(0,h)},Ns=new Q(0),Bs=function(u,e){return((u[0]&15)!=8||u[0]>>4>7||(u[0]<<8|u[1])%31)&&ne(6,"invalid zlib data"),(u[1]>>5&1)==1&&ne(6,"invalid zlib data: "+(u[1]&32?"need":"unexpected")+" dictionary"),(u[1]>>3&4)+2};function Us(u,e){return js(u.subarray(Bs(u),-4),{i:2},e,e)}var Hs=typeof TextDecoder<"u"&&new TextDecoder,Gs=0;try{Hs.decode(Ns,{stream:!0}),Gs=1}catch{}function Yt(u,e,t){const s=t.length-u-1;if(e>=t[s])return s-1;if(e<=t[u])return u;let n=u,r=s,i=Math.floor((n+r)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?r=i:n=i,i=Math.floor((n+r)/2);return i}function Vs(u,e,t,s){const n=[],r=[],i=[];n[0]=1;for(let o=1;o<=t;++o){r[o]=e-s[u+1-o],i[o]=s[u+o]-e;let a=0;for(let l=0;l<o;++l){const f=i[l+1],c=r[o-l],h=n[l]/(f+c);n[l]=a+f*h,a=c*h}n[o]=a}return n}function zs(u,e,t,s){const n=Yt(u,s,e),r=Vs(n,s,u,e),i=new Ce(0,0,0,0);for(let o=0;o<=u;++o){const a=t[n-u+o],l=r[o],f=a.w*l;i.x+=a.x*f,i.y+=a.y*f,i.z+=a.z*f,i.w+=a.w*l}return i}function Xs(u,e,t,s,n){const r=[];for(let c=0;c<=t;++c)r[c]=0;const i=[];for(let c=0;c<=s;++c)i[c]=r.slice(0);const o=[];for(let c=0;c<=t;++c)o[c]=r.slice(0);o[0][0]=1;const a=r.slice(0),l=r.slice(0);for(let c=1;c<=t;++c){a[c]=e-n[u+1-c],l[c]=n[u+c]-e;let h=0;for(let d=0;d<c;++d){const x=l[d+1],v=a[c-d];o[c][d]=x+v;const p=o[d][c-1]/o[c][d];o[d][c]=h+x*p,h=v*p}o[c][c]=h}for(let c=0;c<=t;++c)i[0][c]=o[c][t];for(let c=0;c<=t;++c){let h=0,d=1;const x=[];for(let v=0;v<=t;++v)x[v]=r.slice(0);x[0][0]=1;for(let v=1;v<=s;++v){let p=0;const y=c-v,T=t-v;c>=v&&(x[d][0]=x[h][0]/o[T+1][y],p=x[d][0]*o[y][T]);const g=y>=-1?1:-y,w=c-1<=T?v-1:t-c;for(let E=g;E<=w;++E)x[d][E]=(x[h][E]-x[h][E-1])/o[T+1][y+E],p+=x[d][E]*o[y+E][T];c<=T&&(x[d][v]=-x[h][v-1]/o[T+1][c],p+=x[d][v]*o[c][T]),i[v][c]=p;const R=h;h=d,d=R}}let f=t;for(let c=1;c<=s;++c){for(let h=0;h<=t;++h)i[c][h]*=f;f*=t-c}return i}function Ks(u,e,t,s,n){const r=n<u?n:u,i=[],o=Yt(u,s,e),a=Xs(o,s,u,r,e),l=[];for(let f=0;f<t.length;++f){const c=t[f].clone(),h=c.w;c.x*=h,c.y*=h,c.z*=h,l[f]=c}for(let f=0;f<=r;++f){const c=l[o-u].clone().multiplyScalar(a[f][0]);for(let h=1;h<=u;++h)c.add(l[o-u+h].clone().multiplyScalar(a[f][h]));i[f]=c}for(let f=r+1;f<=n+1;++f)i[f]=new Ce(0,0,0);return i}function Ys(u,e){let t=1;for(let n=2;n<=u;++n)t*=n;let s=1;for(let n=2;n<=e;++n)s*=n;for(let n=2;n<=u-e;++n)s*=n;return t/s}function Ws(u){const e=u.length,t=[],s=[];for(let r=0;r<e;++r){const i=u[r];t[r]=new H(i.x,i.y,i.z),s[r]=i.w}const n=[];for(let r=0;r<e;++r){const i=t[r].clone();for(let o=1;o<=r;++o)i.sub(n[r-o].clone().multiplyScalar(Ys(r,o)*s[o]));n[r]=i.divideScalar(s[0])}return n}function qs(u,e,t,s,n){const r=Ks(u,e,t,s,n);return Ws(r)}class $s extends bn{constructor(e,t,s,n,r){super();const i=t?t.length-1:0,o=s?s.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=n||0,this.endKnot=r||i;for(let a=0;a<o;++a){const l=s[a];this.controlPoints[a]=new Ce(l.x,l.y,l.z,l.w)}}getPoint(e,t=new H){const s=t,n=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=zs(this.degree,this.knots,this.controlPoints,n);return r.w!==1&&r.divideScalar(r.w),s.set(r.x,r.y,r.z)}getTangent(e,t=new H){const s=t,n=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=qs(this.degree,this.knots,this.controlPoints,n,1);return s.copy(r[1]).normalize(),s}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new Ce(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let I,B,Y;class Zs extends Re{constructor(e){super(e)}load(e,t,s,n){const r=this,i=r.path===""?we.extractUrlBase(e):r.path,o=new Pe(this.manager);o.setPath(r.path),o.setResponseType("arraybuffer"),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(a,i))}catch(l){n?n(l):console.error(l),r.manager.itemError(e)}},s,n)}parse(e,t){if(sr(e))I=new nr().parse(e);else{const n=$t(e);if(!rr(n))throw new Error("THREE.FBXLoader: Unknown format.");if(wt(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+wt(n));I=new tr().parse(n)}const s=new _t(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Js(s,this.manager).parse(I)}}class Js{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){B=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),r=new Qs().parse(n);return this.parseScene(n,r,s),Y}parseConnections(){const e=new Map;return"Connections"in I&&I.Connections.connections.forEach(function(s){const n=s[0],r=s[1],i=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const o={ID:r,relationship:i};e.get(n).parents.push(o),e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:n,relationship:i};e.get(r).children.push(a)}),e}parseImages(){const e={},t={};if("Video"in I.Objects){const s=I.Objects.Video;for(const n in s){const r=s[n],i=parseInt(n);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const o=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,a=typeof r.Content=="string"&&r.Content!=="";if(o||a){const l=this.parseImage(s[n]);t[r.RelativeFilename||r.Filename]=l}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let r;switch(n){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),r="image/tga";break;case"webp":r="image/webp";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in I.Objects){const s=I.Objects.Texture;for(const n in s){const r=this.parseTexture(s[n],e);t.set(parseInt(n),r)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,r=e.WrapModeV,i=n!==void 0?n.value:0,o=r!==void 0?r.value:0;if(s.wrapS=i===0?Le:Je,s.wrapT=o===0?Le:Je,"Scaling"in e){const a=e.Scaling.value;s.repeat.x=a[0],s.repeat.y=a[1]}if("Translation"in e){const a=e.Translation.value;s.offset.x=a[0],s.offset.y=a[1]}return s}loadTexture(e,t){const s=e.FileName.split(".").pop().toLowerCase();let n=this.manager.getHandler(`.${s}`);n===null&&(n=this.textureLoader);const r=n.path;r||n.setPath(this.textureLoader.path);const i=B.get(e.id).children;let o;if(i!==void 0&&i.length>0&&t[i[0].ID]!==void 0&&(o=t[i[0].ID],(o.indexOf("blob:")===0||o.indexOf("data:")===0)&&n.setPath(void 0)),o===void 0)return console.warn("FBXLoader: Undefined filename, creating placeholder texture."),new et;const a=n.load(o);return n.setPath(r),a}parseMaterials(e){const t=new Map;if("Material"in I.Objects){const s=I.Objects.Material;for(const n in s){const r=this.parseMaterial(s[n],e);r!==null&&t.set(parseInt(n),r)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!B.has(s))return null;const i=this.parseParameters(e,t,s);let o;switch(r.toLowerCase()){case"phong":o=new Oe;break;case"lambert":o=new _n;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),o=new Oe;break}return o.setValues(i),o.name=n,o}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=oe.colorSpaceToWorking(new G().fromArray(e.Diffuse.value),N):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=oe.colorSpaceToWorking(new G().fromArray(e.DiffuseColor.value),N)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=oe.colorSpaceToWorking(new G().fromArray(e.Emissive.value),N):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=oe.colorSpaceToWorking(new G().fromArray(e.EmissiveColor.value),N)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),n.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(n.opacity===1||n.opacity===0)&&(n.opacity=e.Opacity?parseFloat(e.Opacity.value):null,n.opacity===null&&(n.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=oe.colorSpaceToWorking(new G().fromArray(e.Specular.value),N):e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=oe.colorSpaceToWorking(new G().fromArray(e.SpecularColor.value),N));const r=this;return B.get(s).children.forEach(function(i){const o=i.relationship;switch(o){case"Bump":n.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":n.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=r.getTexture(t,i.ID),n.map!==void 0&&(n.map.colorSpace=N);break;case"DisplacementColor":n.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":n.emissiveMap=r.getTexture(t,i.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=N);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":n.envMap=r.getTexture(t,i.ID),n.envMap!==void 0&&(n.envMap.mapping=Mn,n.envMap.colorSpace=N);break;case"SpecularColor":n.specularMap=r.getTexture(t,i.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=N);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=r.getTexture(t,i.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",o);break}}),n}getTexture(e,t){return"LayeredTexture"in I.Objects&&t in I.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=B.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in I.Objects){const s=I.Objects.Deformer;for(const n in s){const r=s[n],i=B.get(parseInt(n));if(r.attrType==="Skin"){const o=this.parseSkeleton(i,s);o.ID=n,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),o.geometryID=i.parents[0].ID,e[n]=o}else if(r.attrType==="BlendShape"){const o={id:n};o.rawTargets=this.parseMorphTargets(i,s),o.id=n,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=o}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const r=t[n.ID];if(r.attrType!=="Cluster")return;const i={ID:n.ID,indices:[],weights:[],transformLink:new D().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),s.push(i)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const r=e.children[n],i=t[r.ID],o={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;o.geoID=B.get(parseInt(r.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,s.push(o)}return s}parseScene(e,t,s){Y=new _e;const n=this.parseModels(e.skeletons,t,s),r=I.Objects.Model,i=this;n.forEach(function(a){const l=r[a.ID];i.setLookAtProperties(a,l),B.get(a.ID).parents.forEach(function(c){const h=n.get(c.ID);h!==void 0&&h.add(a)}),a.parent===null&&Y.add(a)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),Y.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const l=qt(a.userData.transformData);a.applyMatrix4(l),a.updateWorldMatrix()}});const o=new er().parse();Y.children.length===1&&Y.children[0].isGroup&&(Y.children[0].animations=o,Y=Y.children[0]),Y.animations=o}parseModels(e,t,s){const n=new Map,r=I.Objects.Model;for(const i in r){const o=parseInt(i),a=r[i],l=B.get(o);let f=this.buildSkeleton(l,e,o,a.attrName);if(!f){switch(a.attrType){case"Camera":f=this.createCamera(l);break;case"Light":f=this.createLight(l);break;case"Mesh":f=this.createMesh(l,t,s);break;case"NurbsCurve":f=this.createCurve(l,t);break;case"LimbNode":case"Root":f=new Qe;break;case"Null":default:f=new _e;break}f.name=a.attrName?Ie.sanitizeNodeName(a.attrName):"",f.userData.originalName=a.attrName,f.ID=o}this.getTransformData(f,a),n.set(o,f)}return n}buildSkeleton(e,t,s,n){let r=null;return e.parents.forEach(function(i){for(const o in t){const a=t[o];a.rawBones.forEach(function(l,f){if(l.ID===i.ID){const c=r;r=new Qe,r.matrixWorld.copy(l.transformLink),r.name=n?Ie.sanitizeNodeName(n):"",r.userData.originalName=n,r.ID=s,a.bones[f]=r,c!==null&&r.add(c)}})}}),r}createCamera(e){let t,s;if(e.children.forEach(function(n){const r=I.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ve;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let r=1;s.NearPlane!==void 0&&(r=s.NearPlane.value/1e3);let i=1e3;s.FarPlane!==void 0&&(i=s.FarPlane.value/1e3);let o=window.innerWidth,a=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(o=s.AspectWidth.value,a=s.AspectHeight.value);const l=o/a;let f=45;s.FieldOfView!==void 0&&(f=s.FieldOfView.value);const c=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new Dt(f,l,r,i),c!==null&&t.setFocalLength(c);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new ve;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new ve;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const r=I.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ve;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let r=16777215;s.Color!==void 0&&(r=oe.colorSpaceToWorking(new G().fromArray(s.Color.value),N));let i=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(i=0);let o=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?o=0:o=s.FarAttenuationEnd.value);const a=1;switch(n){case 0:t=new $e(r,i,o,a);break;case 1:t=new bt(r,i);break;case 2:let l=Math.PI/3;s.InnerAngle!==void 0&&(l=X.degToRad(s.InnerAngle.value));let f=0;s.OuterAngle!==void 0&&(f=X.degToRad(s.OuterAngle.value),f=Math.max(f,1)),t=new St(r,i,o,l,f,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new $e(r,i);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,r=null,i=null;const o=[];if(e.children.forEach(function(a){t.has(a.ID)&&(r=t.get(a.ID)),s.has(a.ID)&&o.push(s.get(a.ID))}),o.length>1?i=o:o.length>0?i=o[0]:(i=new Oe({name:Re.DEFAULT_MATERIAL_NAME,color:13421772}),o.push(i)),"color"in r.attributes&&o.forEach(function(a){a.vertexColors=!0}),r.groups.length>0){let a=!1;for(let l=0,f=r.groups.length;l<f;l++){const c=r.groups[l];(c.materialIndex<0||c.materialIndex>=o.length)&&(c.materialIndex=o.length,a=!0)}if(a){const l=new Oe;o.push(l)}}return r.FBX_Deformer?(n=new Ft(r,i),n.normalizeSkinWeights()):n=new ct(r,i),n}createCurve(e,t){const s=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),n=new It({name:Re.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new Pt(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=Fe(t.RotationOrder.value):s.eulerOrder=Fe(0),"Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&B.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const r=I.Objects.Model[n.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),Y.add(e.target)):e.lookAt(new H().fromArray(i))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const r in e){const i=e[r];B.get(parseInt(i.ID)).parents.forEach(function(a){if(t.has(a.ID)){const l=a.ID;B.get(l).parents.forEach(function(c){s.has(c.ID)&&s.get(c.ID).bind(new kt(i.bones),n[c.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in I.Objects){const t=I.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(r){e[r.Node]=new D().fromArray(r.Matrix.a)}):e[n.Node]=new D().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in I){if("AmbientColor"in I.GlobalSettings){const e=I.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const r=new G().setRGB(t,s,n,N);Y.add(new Ln(r,1))}}"UnitScaleFactor"in I.GlobalSettings&&(Y.userData.unitScaleFactor=I.GlobalSettings.UnitScaleFactor.value)}}}class Qs{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in I.Objects){const s=I.Objects.Geometry;for(const n in s){const r=B.get(parseInt(n)),i=this.parseGeometry(r,s[n],e);t.set(parseInt(n),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,r=[],i=e.parents.map(function(c){return I.Objects.Model[c.ID]});if(i.length===0)return;const o=e.children.reduce(function(c,h){return n[h.ID]!==void 0&&(c=n[h.ID]),c},null);e.children.forEach(function(c){s.morphTargets[c.ID]!==void 0&&r.push(s.morphTargets[c.ID])});const a=i[0],l={};"RotationOrder"in a&&(l.eulerOrder=Fe(a.RotationOrder.value)),"InheritType"in a&&(l.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(l.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(l.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(l.scale=a.GeometricScaling.value);const f=qt(l);return this.genGeometry(t,o,r,f)}genGeometry(e,t,s,n){const r=new se;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),o=this.genBuffers(i),a=new K(o.vertex,3);if(a.applyMatrix4(n),r.setAttribute("position",a),o.colors.length>0&&r.setAttribute("color",new K(o.colors,3)),t&&(r.setAttribute("skinIndex",new In(o.weightsIndices,4)),r.setAttribute("skinWeight",new K(o.vertexWeights,4)),r.FBX_Deformer=t),o.normal.length>0){const l=new Cn().getNormalMatrix(n),f=new K(o.normal,3);f.applyNormalMatrix(l),r.setAttribute("normal",f)}if(o.uvs.forEach(function(l,f){const c=f===0?"uv":`uv${f}`;r.setAttribute(c,new K(o.uvs[f],2))}),i.material&&i.material.mappingType!=="AllSame"){let l=o.materialIndex[0],f=0;if(o.materialIndex.forEach(function(c,h){c!==l&&(r.addGroup(f,h-f,l),l=c,f=h)}),r.groups.length>0){const c=r.groups[r.groups.length-1],h=c.start+c.count;h!==o.materialIndex.length&&r.addGroup(h,o.materialIndex.length-h,l)}r.groups.length===0&&r.addGroup(0,o.materialIndex.length,o.materialIndex[0])}return this.addMorphTargets(r,e,s,n),r}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&e.LayerElementColor[0].Colors&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,r){n.indices.forEach(function(i,o){s.weightTable[i]===void 0&&(s.weightTable[i]=[]),s.weightTable[i].push({id:r,weight:n.weights[o]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,r=!1,i=[],o=[],a=[],l=[],f=[],c=[];const h=this;return e.vertexIndices.forEach(function(d,x){let v,p=!1;d<0&&(d=d^-1,p=!0);let y=[],T=[];if(i.push(d*3,d*3+1,d*3+2),e.color){const g=je(x,s,d,e.color);a.push(g[0],g[1],g[2])}if(e.skeleton){if(e.weightTable[d]!==void 0&&e.weightTable[d].forEach(function(g){T.push(g.weight),y.push(g.id)}),T.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const g=[0,0,0,0],w=[0,0,0,0];T.forEach(function(R,E){let b=R,A=y[E];w.forEach(function(M,_,S){if(b>M){S[_]=b,b=M;const F=g[_];g[_]=A,A=F}})}),y=g,T=w}for(;T.length<4;)T.push(0),y.push(0);for(let g=0;g<4;++g)f.push(T[g]),c.push(y[g])}if(e.normal){const g=je(x,s,d,e.normal);o.push(g[0],g[1],g[2])}e.material&&e.material.mappingType!=="AllSame"&&(v=je(x,s,d,e.material)[0],v<0&&(h.negativeMaterialIndices=!0,v=0)),e.uv&&e.uv.forEach(function(g,w){const R=je(x,s,d,g);l[w]===void 0&&(l[w]=[]),l[w].push(R[0]),l[w].push(R[1])}),n++,p&&(h.genFace(t,e,i,v,o,a,l,f,c,n),s++,n=0,i=[],o=[],a=[],l=[],f=[],c=[])}),t}getNormalNewell(e){const t=new H(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],r=e[(s+1)%e.length];t.x+=(n.y-r.y)*(n.z+r.z),t.y+=(n.z-r.z)*(n.x+r.x),t.z+=(n.x-r.x)*(n.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new H(0,1,0):new H(0,0,1)).cross(t).normalize(),r=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:r}}flattenVertex(e,t,s){return new at(e.dot(t),e.dot(s))}genFace(e,t,s,n,r,i,o,a,l,f){let c;if(f>3){const h=[],d=t.baseVertexPositions||t.vertexPositions;for(let y=0;y<s.length;y+=3)h.push(new H(d[s[y]],d[s[y+1]],d[s[y+2]]));const{tangent:x,bitangent:v}=this.getNormalTangentAndBitangent(h),p=[];for(const y of h)p.push(this.flattenVertex(y,x,v));c=Fn.triangulateShape(p,[])}else c=[[0,1,2]];for(const[h,d,x]of c)e.vertex.push(t.vertexPositions[s[h*3]]),e.vertex.push(t.vertexPositions[s[h*3+1]]),e.vertex.push(t.vertexPositions[s[h*3+2]]),e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),e.vertex.push(t.vertexPositions[s[x*3]]),e.vertex.push(t.vertexPositions[s[x*3+1]]),e.vertex.push(t.vertexPositions[s[x*3+2]]),t.skeleton&&(e.vertexWeights.push(a[h*4]),e.vertexWeights.push(a[h*4+1]),e.vertexWeights.push(a[h*4+2]),e.vertexWeights.push(a[h*4+3]),e.vertexWeights.push(a[d*4]),e.vertexWeights.push(a[d*4+1]),e.vertexWeights.push(a[d*4+2]),e.vertexWeights.push(a[d*4+3]),e.vertexWeights.push(a[x*4]),e.vertexWeights.push(a[x*4+1]),e.vertexWeights.push(a[x*4+2]),e.vertexWeights.push(a[x*4+3]),e.weightsIndices.push(l[h*4]),e.weightsIndices.push(l[h*4+1]),e.weightsIndices.push(l[h*4+2]),e.weightsIndices.push(l[h*4+3]),e.weightsIndices.push(l[d*4]),e.weightsIndices.push(l[d*4+1]),e.weightsIndices.push(l[d*4+2]),e.weightsIndices.push(l[d*4+3]),e.weightsIndices.push(l[x*4]),e.weightsIndices.push(l[x*4+1]),e.weightsIndices.push(l[x*4+2]),e.weightsIndices.push(l[x*4+3])),t.color&&(e.colors.push(i[h*3]),e.colors.push(i[h*3+1]),e.colors.push(i[h*3+2]),e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2]),e.colors.push(i[x*3]),e.colors.push(i[x*3+1]),e.colors.push(i[x*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(r[h*3]),e.normal.push(r[h*3+1]),e.normal.push(r[h*3+2]),e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2]),e.normal.push(r[x*3]),e.normal.push(r[x*3+1]),e.normal.push(r[x*3+2])),t.uv&&t.uv.forEach(function(v,p){e.uvs[p]===void 0&&(e.uvs[p]=[]),e.uvs[p].push(o[p][h*2]),e.uvs[p].push(o[p][h*2+1]),e.uvs[p].push(o[p][d*2]),e.uvs[p].push(o[p][d*2+1]),e.uvs[p].push(o[p][x*2]),e.uvs[p].push(o[p][x*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;s.forEach(function(i){i.rawTargets.forEach(function(o){const a=I.Objects.Geometry[o.geoID];a!==void 0&&r.genMorphGeometry(e,t,a,n,o.name)})})}genMorphGeometry(e,t,s,n,r){const i=t.Vertices!==void 0?t.Vertices.a:[],o=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=s.Vertices!==void 0?s.Vertices.a:[],l=s.Indexes!==void 0?s.Indexes.a:[],f=e.attributes.position.count*3,c=new Float32Array(f);for(let v=0;v<l.length;v++){const p=l[v]*3;c[p]=a[v*3],c[p+1]=a[v*3+1],c[p+2]=a[v*3+2]}const h={vertexIndices:o,vertexPositions:c,baseVertexPositions:i},d=this.genBuffers(h),x=new K(d.vertex,3);x.name=r||s.attrName,x.applyMatrix4(n),e.morphAttributes.position.push(x)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let r=[];return s==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:r,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let r=[];return s==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:n,indices:r,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let r=[];s==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,o=new G;i<n.length;i+=4)o.fromArray(n,i),oe.colorSpaceToWorking(o,N),o.toArray(n,i);return{dataSize:4,buffer:n,indices:r,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,r=[];for(let i=0;i<n.length;++i)r.push(i);return{dataSize:1,buffer:n,indices:r,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new se;const s=t-1,n=e.KnotVector.a,r=[],i=e.Points.a;for(let c=0,h=i.length;c<h;c+=4)r.push(new Ce().fromArray(i,c));let o,a;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){o=s,a=n.length-1-o;for(let c=0;c<s;++c)r.push(r[c])}const f=new $s(s,n,r,o,a).getPoints(r.length*12);return new se().setFromPoints(f)}}class er{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],r=this.addClip(n);e.push(r)}return e}parseClips(){if(I.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=I.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:n.id,attr:n.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=I.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(ir),values:t[s].KeyValueFloat.a},r=B.get(n.id);if(r!==void 0){const i=r.parents[0].ID,o=r.parents[0].relationship;o.match(/X/)?e.get(i).curves.x=n:o.match(/Y/)?e.get(i).curves.y=n:o.match(/Z/)?e.get(i).curves.z=n:o.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=n)}}}parseAnimationLayers(e){const t=I.Objects.AnimationLayer,s=new Map;for(const n in t){const r=[],i=B.get(parseInt(n));i!==void 0&&(i.children.forEach(function(a,l){if(e.has(a.ID)){const f=e.get(a.ID);if(f.curves.x!==void 0||f.curves.y!==void 0||f.curves.z!==void 0){if(r[l]===void 0){const c=B.get(a.ID).parents.filter(function(h){return h.relationship!==void 0})[0].ID;if(c!==void 0){const h=I.Objects.Model[c.toString()];if(h===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const d={modelName:h.attrName?Ie.sanitizeNodeName(h.attrName):"",ID:h.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};Y.traverse(function(x){x.ID===h.id&&(d.transform=x.matrix,x.userData.transformData&&(d.eulerOrder=x.userData.transformData.eulerOrder))}),d.transform||(d.transform=new D),"PreRotation"in h&&(d.preRotation=h.PreRotation.value),"PostRotation"in h&&(d.postRotation=h.PostRotation.value),r[l]=d}}r[l]&&(r[l][f.attr]=f)}else if(f.curves.morph!==void 0){if(r[l]===void 0){const c=B.get(a.ID).parents.filter(function(y){return y.relationship!==void 0})[0].ID,h=B.get(c).parents[0].ID,d=B.get(h).parents[0].ID,x=B.get(d).parents[0].ID,v=I.Objects.Model[x],p={modelName:v.attrName?Ie.sanitizeNodeName(v.attrName):"",morphName:I.Objects.Deformer[c].attrName};r[l]=p}r[l][f.attr]=f}}}),s.set(parseInt(n),r))}return s}parseAnimStacks(e){const t=I.Objects.AnimationStack,s={};for(const n in t){const r=B.get(parseInt(n)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);s[n]={name:t[n].attrName,layer:i}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new Ot(e.name,-1,t)}generateTracks(e){const t=[];let s=new H,n=new H;if(e.transform&&e.transform.decompose(s,new re,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,s,n){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,s);return new tt(e+"."+n,r,i)}generateRotationTrack(e,t,s,n,r){let i,o;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const h=this.interpolateRotations(t.x,t.y,t.z,r);i=h[0],o=h[1]}const a=Fe(0);s!==void 0&&(s=s.map(X.degToRad),s.push(a),s=new ge().fromArray(s),s=new re().setFromEuler(s)),n!==void 0&&(n=n.map(X.degToRad),n.push(a),n=new ge().fromArray(n),n=new re().setFromEuler(n).invert());const l=new re,f=new ge,c=[];if(!o||!i)return new Ne(e+".quaternion",[0],[0]);for(let h=0;h<o.length;h+=3)f.set(o[h],o[h+1],o[h+2],r),l.setFromEuler(f),s!==void 0&&l.premultiply(s),n!==void 0&&l.multiply(n),h>2&&new re().fromArray(c,(h-3)/3*4).dot(l)<0&&l.set(-l.x,-l.y,-l.z,-l.w),l.toArray(c,h/3*4);return new Ne(e+".quaternion",i,c)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(r){return r/100}),n=Y.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new nt(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==n&&(t[s]=i,n=i,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,r=[];let i=-1,o=-1,a=-1;return e.forEach(function(l){if(t.x&&(i=t.x.times.indexOf(l)),t.y&&(o=t.y.times.indexOf(l)),t.z&&(a=t.z.times.indexOf(l)),i!==-1){const f=t.x.values[i];r.push(f),n[0]=f}else r.push(n[0]);if(o!==-1){const f=t.y.values[o];r.push(f),n[1]=f}else r.push(n[1]);if(a!==-1){const f=t.z.values[a];r.push(f),n[2]=f}else r.push(n[2])}),r}interpolateRotations(e,t,s,n){const r=[],i=[];r.push(e.times[0]),i.push(X.degToRad(e.values[0])),i.push(X.degToRad(t.values[0])),i.push(X.degToRad(s.values[0]));for(let o=1;o<e.values.length;o++){const a=[e.values[o-1],t.values[o-1],s.values[o-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const l=a.map(X.degToRad),f=[e.values[o],t.values[o],s.values[o]];if(isNaN(f[0])||isNaN(f[1])||isNaN(f[2]))continue;const c=f.map(X.degToRad),h=[f[0]-a[0],f[1]-a[1],f[2]-a[2]],d=[Math.abs(h[0]),Math.abs(h[1]),Math.abs(h[2])];if(d[0]>=180||d[1]>=180||d[2]>=180){const v=Math.max(...d)/180,p=new ge(...l,n),y=new ge(...c,n),T=new re().setFromEuler(p),g=new re().setFromEuler(y);T.dot(g)&&g.set(-g.x,-g.y,-g.z,-g.w);const w=e.times[o-1],R=e.times[o]-w,E=new re,b=new ge;for(let A=0;A<1;A+=1/v)E.copy(T.clone().slerp(g.clone(),A)),r.push(w+A*R),b.setFromQuaternion(E,n),i.push(b.x),i.push(b.y),i.push(b.z)}else r.push(e.times[o]),i.push(X.degToRad(e.values[o])),i.push(X.degToRad(t.values[o])),i.push(X.degToRad(s.values[o]))}return[r,i]}}class tr{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new Wt,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,r){const i=n.match(/^[\s\t]*;/),o=n.match(/^[\s\t]*$/);if(i||o)return;const a=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),l=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),f=n.match("^\\t{"+(t.currentIndent-1)+"}}");a?t.parseNodeBegin(n,a):l?t.parseNodeProperty(n,l,s[++r]):f?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:s},i=this.parseNodeAttr(n),o=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,r):s in o?(s==="PoseNode"?o.PoseNode.push(r):o[s].id!==void 0&&(o[s]={},o[s][o[s].id]=o[s]),i.id!==""&&(o[s][i.id]=r)):typeof i.id=="number"?(o[s]={},o[s][i.id]=r):s!=="Properties70"&&(s==="PoseNode"?o[s]=[r]:o[s]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&r===","&&(r=s.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,n,r);return}if(n==="C"){const a=r.split(",").slice(1),l=parseInt(a[0]),f=parseInt(a[1]);let c=r.split(",").slice(3);c=c.map(function(h){return h.trim().replace(/^"/,"")}),n="connections",r=[l,f],ar(r,c),i[n]===void 0&&(i[n]=[])}n==="Node"&&(i.id=r),n in i&&Array.isArray(i[n])?i[n].push(r):n!=="a"?i[n]=r:i.a=r,this.setCurrentProp(i,n),n==="a"&&r.slice(-1)!==","&&(i.a=We(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=We(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(f){return f.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=n[0],i=n[1],o=n[2],a=n[3];let l=n[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=We(l);break}this.getPrevNode()[r]={type:i,type2:o,flag:a,value:l},this.setCurrentProp(this.getPrevNode(),r)}}class nr{parse(e){const t=new Tt(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new Wt;for(;!this.endOfContent(t);){const r=this.parseNode(t,s);r!==null&&n.add(r.name,r)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),o=e.getString(i);if(n===0)return null;const a=[];for(let h=0;h<r;h++)a.push(this.parseProperty(e));const l=a.length>0?a[0]:"",f=a.length>1?a[1]:"",c=a.length>2?a[2]:"";for(s.singleProperty=r===1&&e.getOffset()===n;n>e.getOffset();){const h=this.parseNode(e,t);h!==null&&this.parseSubNode(o,s,h)}return s.propertyList=a,typeof l=="number"&&(s.id=l),f!==""&&(s.attrName=f),c!==""&&(s.attrType=c),o!==""&&(s.name=o),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(r,i){i!==0&&n.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(r){t[r]=s[r]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],r=s.propertyList[1];const i=s.propertyList[2],o=s.propertyList[3];let a;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?a=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:a=s.propertyList[4],t[n]={type:r,type2:i,flag:o,value:a}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const o=Us(new Uint8Array(e.getArrayBuffer(i))),a=new Tt(o.buffer);switch(t){case"b":case"c":return a.getBooleanArray(n);case"d":return a.getFloat64Array(n);case"f":return a.getFloat32Array(n);case"i":return a.getInt32Array(n);case"l":return a.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class Tt{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class Wt{add(e,t){this[e]=t}}function sr(u){const e="Kaydara FBX Binary  \0";return u.byteLength>=e.length&&e===$t(u,0,e.length)}function rr(u){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const r=u[n-1];return u=u.slice(t+n),t++,r}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function wt(u){const e=/FBXVersion: (\d+)/,t=u.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function ir(u){return u/46186158e3}const or=[];function je(u,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=u;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const r=n*s.dataSize,i=r+s.dataSize;return cr(or,s.buffer,r,i)}const Ye=new ge,ye=new H;function qt(u){const e=new D,t=new D,s=new D,n=new D,r=new D,i=new D,o=new D,a=new D,l=new D,f=new D,c=new D,h=new D,d=u.inheritType?u.inheritType:0;u.translation&&e.setPosition(ye.fromArray(u.translation));const x=Fe(0);if(u.preRotation){const S=u.preRotation.map(X.degToRad);S.push(x),t.makeRotationFromEuler(Ye.fromArray(S))}if(u.rotation){const S=u.rotation.map(X.degToRad);S.push(u.eulerOrder||x),s.makeRotationFromEuler(Ye.fromArray(S))}if(u.postRotation){const S=u.postRotation.map(X.degToRad);S.push(x),n.makeRotationFromEuler(Ye.fromArray(S)),n.invert()}u.scale&&r.scale(ye.fromArray(u.scale)),u.scalingOffset&&o.setPosition(ye.fromArray(u.scalingOffset)),u.scalingPivot&&i.setPosition(ye.fromArray(u.scalingPivot)),u.rotationOffset&&a.setPosition(ye.fromArray(u.rotationOffset)),u.rotationPivot&&l.setPosition(ye.fromArray(u.rotationPivot)),u.parentMatrixWorld&&(c.copy(u.parentMatrix),f.copy(u.parentMatrixWorld));const v=t.clone().multiply(s).multiply(n),p=new D;p.extractRotation(f);const y=new D;y.copyPosition(f);const T=y.clone().invert().multiply(f),g=p.clone().invert().multiply(T),w=r,R=new D;if(d===0)R.copy(p).multiply(v).multiply(g).multiply(w);else if(d===1)R.copy(p).multiply(g).multiply(v).multiply(w);else{const F=new D().scale(new H().setFromMatrixScale(c)).clone().invert(),z=g.clone().multiply(F);R.copy(p).multiply(v).multiply(z).multiply(w)}const E=l.clone().invert(),b=i.clone().invert();let A=e.clone().multiply(a).multiply(l).multiply(t).multiply(s).multiply(n).multiply(E).multiply(o).multiply(i).multiply(r).multiply(b);const M=new D().copyPosition(A),_=f.clone().multiply(M);return h.copyPosition(_),A=h.clone().multiply(R),A.premultiply(f.invert()),A}function Fe(u){u=u||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return u===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[u]}function We(u){return u.split(",").map(function(t){return parseFloat(t)})}function $t(u,e,t){return e===void 0&&(e=0),t===void 0&&(t=u.byteLength),new TextDecoder().decode(new Uint8Array(u,e,t))}function ar(u,e){for(let t=0,s=u.length,n=e.length;t<n;t++,s++)u[s]=e[t]}function cr(u,e,t,s){for(let n=t,r=0;n<s;n++,r++)u[r]=e[n];return u}const lr={".obj":"Wavefront OBJ",".stl":"STL (Stereolithography)",".ply":"PLY (Polygon File Format)",".gltf":"glTF",".glb":"glTF Binary",".fbx":"Autodesk FBX"},ur=Object.keys(lr).join(",");function Zt(u){const e=u.toLowerCase().match(/\.[^.]+$/);return e?e[0]:""}function Be(u){const e=[],t=[];if(!u.index){const r=u.getAttribute("position"),i=[];for(let o=0;o<r.count;o++)i.push(o);u.setIndex(i)}const s=u.getAttribute("position");for(let r=0;r<s.count;r++)e.push([s.getX(r),s.getY(r),s.getZ(r)]);const n=u.index;if(n)for(let r=0;r<n.count;r+=3)t.push([n.getX(r),n.getX(r+1),n.getX(r+2)]);return{vertices:e,faces:t}}function Jt(u){const e=[];if(u.traverse(i=>{if(i instanceof ct&&i.geometry){const o=i.geometry.clone();i.updateWorldMatrix(!0,!1),o.applyMatrix4(i.matrixWorld);const a=o.getAttribute("position"),l=new se;l.setAttribute("position",a),o.index&&l.setIndex(o.index),e.push(l)}}),e.length===0)return null;if(e.length===1)return e[0];const t=new se,s=[],n=[];let r=0;for(const i of e){const o=i.getAttribute("position");for(let a=0;a<o.count;a++)s.push(o.getX(a),o.getY(a),o.getZ(a));if(i.index)for(let a=0;a<i.index.count;a++)n.push(i.index.getX(a)+r);else for(let a=0;a<o.count;a++)n.push(a+r);r+=o.count}return t.setAttribute("position",new K(s,3)),t.setIndex(n),t}async function Qt(u){const e=[],t=[],s=u.split(`
`);for(const n of s){const r=n.trim();if(!r||r.startsWith("#"))continue;const i=r.split(/\s+/);if(i[0]==="v")e.push([parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])]);else if(i[0]==="f"){const o=i.slice(1,4).map(a=>parseInt(a.split("/")[0])-1);o.length===3&&t.push(o)}}if(e.length===0||t.length===0)throw new Error("No valid mesh data found in OBJ file");return{vertices:e,faces:t}}async function en(u){const t=new Vn().parse(u);return Be(t)}async function tn(u){const t=new zn().parse(u);return Be(t)}async function nn(u){return new Promise((e,t)=>{const s=new Kn,n=new Blob([u]),r=URL.createObjectURL(n);s.load(r,i=>{URL.revokeObjectURL(r);const o=Jt(i.scene);if(!o){t(new Error("No mesh found in glTF file"));return}e(Be(o))},void 0,i=>{URL.revokeObjectURL(r),t(i)})})}async function sn(u){return new Promise((e,t)=>{const s=new Zs,n=new Blob([u]),r=URL.createObjectURL(n);s.load(r,i=>{URL.revokeObjectURL(r);const o=Jt(i);if(!o){t(new Error("No mesh found in FBX file"));return}e(Be(o))},void 0,i=>{URL.revokeObjectURL(r),t(i)})})}async function fr(u){const e=Zt(u.name);switch(e){case".obj":{const t=await u.text();return Qt(t)}case".stl":{const t=await u.arrayBuffer();return en(t)}case".ply":{const t=await u.arrayBuffer();return tn(t)}case".gltf":case".glb":{const t=await u.arrayBuffer();return nn(t)}case".fbx":{const t=await u.arrayBuffer();return sn(t)}default:throw new Error(`Unsupported file format: ${e}`)}}async function hr(u){const e=await fetch(u);if(!e.ok)throw new Error(`Failed to fetch: ${u}`);const t=Zt(u);switch(t){case".obj":{const s=await e.text();return Qt(s)}case".stl":{const s=await e.arrayBuffer();return en(s)}case".ply":{const s=await e.arrayBuffer();return tn(s)}case".gltf":case".glb":{const s=await e.arrayBuffer();return nn(s)}case".fbx":{const s=await e.arrayBuffer();return sn(s)}default:throw new Error(`Unsupported file format: ${t}`)}}function pr({onFileSelect:u,onAnalyze:e,numEigenpairs:t,onNumEigenpairsChange:s,filterCurvePoints:n,onFilterCurveChange:r,selectedEigenvectorIndex:i,onEigenvectorIndexChange:o,isProcessing:a,isAnalyzing:l,isReady:f,isLoadingDefault:c,spectrumInfo:h,hasMesh:d,analysisStatus:x}){const v=p=>{const y=p.target.files?.[0];y&&u(y)};return m.jsxs("div",{className:"control-panel",children:[m.jsxs("h2",{children:["Spectral Mesh Filter",m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"スペクトルメッシュフィルター"}),m.jsx("p",{children:"3Dメッシュを周波数成分に分解し、フィルタリングを行うツールです。"}),m.jsx("p",{children:"メッシュの形状を「低周波（なめらかな形状）」と「高周波（細かいディテール）」に分けて操作できます。"})]})})]}),m.jsxs("div",{className:"control-group",children:[m.jsxs("label",{htmlFor:"file-upload",children:["Upload 3D Model",m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"3Dモデルのアップロード"}),m.jsx("p",{children:"以下の形式に対応しています:"}),m.jsxs("ul",{children:[m.jsxs("li",{children:[m.jsx("strong",{children:"OBJ"})," - Wavefront OBJ"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"STL"})," - Stereolithography"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"PLY"})," - Polygon File Format"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"glTF/GLB"})," - GL Transmission Format"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"FBX"})," - Autodesk FBX"]})]}),m.jsx("p",{children:"デフォルトではStanford Bunnyが読み込まれています。"})]})})]}),m.jsx("input",{id:"file-upload",type:"file",accept:ur,onChange:v,disabled:a||l||!f})]}),m.jsxs("div",{className:"button-with-help",children:[m.jsx("button",{className:"filter-button",onClick:e,disabled:a||l||!f||!d,children:l?"Analyzing...":"Analyze Spectrum"}),m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"スペクトル解析"}),m.jsx("p",{children:"メッシュのラプラシアン行列を計算し、固有値分解を行います。"}),m.jsx("p",{children:m.jsx("strong",{children:"処理内容:"})}),m.jsxs("ol",{children:[m.jsx("li",{children:"DECラプラシアン行列の構築"}),m.jsx("li",{children:"固有値・固有ベクトルの計算"}),m.jsx("li",{children:"フーリエ係数（MHT）の計算"})]}),m.jsx("p",{children:"※ 頂点数が多いと数分かかる場合があります"})]})})]}),h&&m.jsxs(m.Fragment,{children:[m.jsxs("div",{className:"control-group",children:[m.jsxs("label",{htmlFor:"eigenpairs",children:["Eigenpairs: ",t," / ",h.maxEigenpairs,m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"固有対数 (Eigenpairs)"}),m.jsx("p",{children:"再構成に使用する固有値・固有ベクトルのペア数です。"}),m.jsxs("ul",{children:[m.jsxs("li",{children:[m.jsx("strong",{children:"少ない:"})," 低周波成分のみ（なめらか）"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"多い:"})," より多くの周波数成分を含む（詳細）"]})]}),m.jsx("p",{children:"値を小さくするとローパスフィルター効果があります。"})]})})]}),m.jsx("input",{id:"eigenpairs",type:"range",min:"10",max:h.maxEigenpairs,step:"10",value:t,onChange:p=>s(Number(p.target.value)),disabled:a||l}),m.jsxs("div",{className:"range-labels",children:[m.jsx("span",{children:"10"}),m.jsx("span",{children:h.maxEigenpairs})]})]}),m.jsxs("div",{className:"control-group curve-editor-section",children:[m.jsxs("label",{children:["フィルターカーブ (周波数応答)",m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"フィルターカーブ"}),m.jsx("p",{children:"各周波数成分にどれだけの強度を適用するかを設定します。"}),m.jsxs("ul",{children:[m.jsxs("li",{children:[m.jsx("strong",{children:"横軸:"})," 固有値インデックス（左=低周波、右=高周波）"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"縦軸:"})," フィルター値（0〜2）"]})]}),m.jsx("p",{children:m.jsx("strong",{children:"操作方法:"})}),m.jsxs("ul",{children:[m.jsx("li",{children:"ドラッグ: 制御点を移動"}),m.jsx("li",{children:"ダブルクリック: 点を追加/削除"})]}),m.jsx("p",{children:m.jsx("strong",{children:"フィルター値の意味:"})}),m.jsxs("ul",{children:[m.jsx("li",{children:"1.0: 元のまま"}),m.jsx("li",{children:"0.0: 完全にカット"}),m.jsx("li",{children:"2.0: 2倍に増幅"})]})]})})]}),m.jsx(Gn,{points:n,onChange:r,maxEigenpairs:h.maxEigenpairs,disabled:a||l})]}),m.jsxs("div",{className:"control-group eigenvector-section",children:[m.jsxs("label",{htmlFor:"eigenvector-index",children:["基底関数表示: φ",m.jsx("sub",{children:i}),m.jsx(xe,{content:m.jsxs("div",{children:[m.jsx("strong",{children:"基底関数（固有ベクトル）の可視化"}),m.jsx("p",{children:"選択した固有ベクトルをメッシュ上に色で表示します。"}),m.jsxs("ul",{children:[m.jsxs("li",{children:[m.jsx("strong",{children:"青:"})," 負の値"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"白:"})," ゼロ付近"]}),m.jsxs("li",{children:[m.jsx("strong",{children:"赤:"})," 正の値"]})]}),m.jsx("p",{children:"低いインデックスは低周波（大きな構造）、高いインデックスは高周波（細かい変動）を表します。"}),m.jsx("p",{children:"これらの基底関数の線形結合でメッシュ形状が表現されます。"})]})})]}),m.jsx("input",{id:"eigenvector-index",type:"range",min:"1",max:h.maxEigenpairs-1,step:"1",value:i,onChange:p=>o(Number(p.target.value)),disabled:a||l}),m.jsxs("div",{className:"range-labels",children:[m.jsx("span",{children:"1 (低周波)"}),m.jsxs("span",{children:[h.maxEigenpairs-1," (高周波)"]})]}),m.jsxs("div",{className:"color-legend",children:[m.jsx("span",{className:"legend-negative",children:"負"}),m.jsx("span",{className:"legend-positive",children:"正"})]})]})]}),!f&&m.jsx("div",{className:"status",children:"Initializing Pyodide..."}),c&&m.jsx("div",{className:"status",children:"Loading default model..."}),x&&m.jsxs("div",{className:"status-box",children:[m.jsx("div",{className:"status-label",children:"Status:"}),m.jsx("div",{className:"status-text",children:x}),l&&m.jsx("div",{className:"status-spinner"})]})]})}function dr({targetPosition:u,enabled:e,onFocused:t}){const{camera:s}=On();return L.useEffect(()=>{e&&(s.position.set(u[0]+3,2.5,4),s.lookAt(u[0],.75,0),t())},[s,u,e,t]),null}const At=[{x:0,y:1},{x:1,y:1}];function mr(){const[u,e]=L.useState(null),[t,s]=L.useState(null),[n,r]=L.useState(!1),[i,o]=L.useState(!1),[a,l]=L.useState(100),[f,c]=L.useState(At),[h,d]=L.useState(!0),[x,v]=L.useState(null),[p,y]=L.useState(""),[T,g]=L.useState(!1),[w,R]=L.useState(0),[E,b]=L.useState(null),A=L.useRef(null),M=L.useRef(null),{pyodide:_,isReady:S,error:F}=Nn(["spectral_mesh_processing.py"]),z=L.useMemo(()=>{if(u)return lt(u)},[u]);L.useEffect(()=>{(async()=>{try{const O=await hr("/my-site/python-apps/bunny.obj");e(O)}catch(O){console.error("Failed to load default model:",O)}finally{d(!1)}})()},[]);const ee=async P=>{try{const O=await fr(P);e(O),s(null),v(null),g(!1),c(At)}catch(O){console.error("Failed to load model:",O),alert(`ファイルの読み込みに失敗しました: ${O instanceof Error?O.message:"Unknown error"}`)}},V=L.useCallback(async(P,O)=>{if(!(!_||!S||!x||!u)){r(!0);try{const U=[];for(let de=0;de<P;de++){const ke=P>1?de/(P-1):0;U.push(Nt(O,ke))}const he=Hn(O);console.log("Filter values sample:",U.slice(0,5),"... length:",U.length),console.log("Curve average:",he),await _.runPythonAsync(`
import numpy as np

# 指定された固有対数とフィルター値で再構成
num_eigenpairs_to_use = ${P}
filter_values = np.array(${JSON.stringify(U)})
curve_average = ${he}

# フーリエ係数にフィルター値を適用
# fourier_X, fourier_Y, fourier_Z は compute_spectrum で計算済み
filtered_fourier_X = filter_values[:num_eigenpairs_to_use] * processor.fourier_X[:num_eigenpairs_to_use]
filtered_fourier_Y = filter_values[:num_eigenpairs_to_use] * processor.fourier_Y[:num_eigenpairs_to_use]
filtered_fourier_Z = filter_values[:num_eigenpairs_to_use] * processor.fourier_Z[:num_eigenpairs_to_use]

# 逆MHT（逆変換）で頂点座標を再構成
eigenvectors_subset = processor.eigenvectors[:, :num_eigenpairs_to_use]
X_reconstructed = eigenvectors_subset @ filtered_fourier_X
Y_reconstructed = eigenvectors_subset @ filtered_fourier_Y
Z_reconstructed = eigenvectors_subset @ filtered_fourier_Z

reconstructed = np.column_stack([X_reconstructed, Y_reconstructed, Z_reconstructed])

# 再構成 = フィルター適用済み成分 + 残差 * カーブ平均値
reconstructed_vertices = (reconstructed + fixed_residual * curve_average).tolist()
reconstructed_faces = faces.tolist()

print(f"再構成完了: 固有対数={num_eigenpairs_to_use}, フィルター平均={np.mean(filter_values):.4f}, 残差ゲイン={curve_average:.4f}")
      `);const pe=_.globals.get("reconstructed_vertices").toJs(),Ee=_.globals.get("reconstructed_faces").toJs();s({vertices:Array.from(pe),faces:Array.from(Ee)})}catch(U){console.error("Reconstruction error:",U)}finally{r(!1)}}},[_,S,x,u]),j=async()=>{if(!(!u||!_||!S)){o(!0),s(null);try{y("Step 1/2: Laplacian行列を構築中..."),await new Promise(U=>setTimeout(U,50)),await _.runPythonAsync(`
import numpy as np
from spectral_mesh_processing import SpectralMeshProcessor

# メッシュデータを設定
vertices = np.array(${JSON.stringify(u.vertices)})
faces = np.array(${JSON.stringify(u.faces)})
print(f"頂点数: {len(vertices)}, 面数: {len(faces)}")

# スペクトル処理クラスを初期化
processor = SpectralMeshProcessor(vertices, faces, dual_type='circumcentric')
# Laplacian行列を構築
processor.compute_laplacian()
print("Laplacian行列の構築完了")
      `),y("Step 2/2: 固有値・固有ベクトル・スペクトル係数を計算中... (数分かかる場合があります)"),await new Promise(U=>setTimeout(U,50)),await _.runPythonAsync(`
# スペクトル分解（固有対数は自動決定、スペクトル係数も計算）
processor.compute_spectrum(verbose=False)

# 結果を格納
spectrum_max_eigenpairs = len(processor.eigenvalues)
spectrum_nyquist_frequency = float(processor.nyquist_frequency)

# 固定の残差を計算（全固有対で再構成してもオリジナルと一致しない部分）
# これは固有対数に関係なく一定
max_freq_all = processor.frequencies[-1]
full_reconstruction = processor.apply_lowpass_filter(
    cutoff_freq=max_freq_all,
    include_residual=False,
    verbose=False
)
fixed_residual = vertices - full_reconstruction
print(f"残差のノルム: {np.linalg.norm(fixed_residual):.6f}")

print(f"解析完了: 固有対数={spectrum_max_eigenpairs}, ナイキスト周波数={spectrum_nyquist_frequency:.2f}")
      `);const P=_.globals.get("spectrum_max_eigenpairs"),O=_.globals.get("spectrum_nyquist_frequency");v({maxEigenpairs:P,nyquistFrequency:O}),l(P),y(`✅ 解析完了: ${P}固有対, ナイキスト周波数=${O.toFixed(2)}`),o(!1),r(!0);try{await _.runPythonAsync(`
# フィルターなしで再構成（全固有対を使用）
X_reconstructed = processor.eigenvectors @ processor.fourier_X
Y_reconstructed = processor.eigenvectors @ processor.fourier_Y
Z_reconstructed = processor.eigenvectors @ processor.fourier_Z
reconstructed = np.column_stack([X_reconstructed, Y_reconstructed, Z_reconstructed])

# 残差を加える（= オリジナルと同じ）
reconstructed_vertices = (reconstructed + fixed_residual).tolist()
reconstructed_faces = faces.tolist()
print("初期再構成完了（フィルターなし）")
        `);const U=_.globals.get("reconstructed_vertices").toJs(),he=_.globals.get("reconstructed_faces").toJs();s({vertices:Array.from(U),faces:Array.from(he)})}finally{r(!1)}g(!0)}catch(P){console.error("Analyze error:",P),y("❌ エラーが発生しました"),o(!1)}}},Z=L.useCallback(P=>{l(P),A.current&&clearTimeout(A.current),A.current=setTimeout(()=>{V(P,f)},300)},[V,f]),W=L.useCallback(P=>{c(P),A.current&&clearTimeout(A.current),A.current=setTimeout(()=>{V(a,P)},300)},[V,a]),$=L.useCallback(async P=>{if(!(!_||!S||!x))try{await _.runPythonAsync(`
# 指定されたインデックスの固有ベクトルを取得
eigenvector_index = ${P}
eigenvector_data = processor.eigenvectors[:, eigenvector_index].tolist()
      `);const O=_.globals.get("eigenvector_data").toJs();b(Array.from(O))}catch(O){console.error("Failed to fetch eigenvector:",O)}},[_,S,x]),Ue=L.useCallback(P=>{R(P),M.current&&clearTimeout(M.current),M.current=setTimeout(()=>{$(P)},100)},[$]);return L.useEffect(()=>{x&&_&&S&&(R(1),$(1))},[x,_,S,$]),L.useEffect(()=>()=>{A.current&&clearTimeout(A.current),M.current&&clearTimeout(M.current)},[]),m.jsxs("div",{className:"app-container",children:[m.jsx(pr,{onFileSelect:ee,onAnalyze:j,numEigenpairs:a,onNumEigenpairsChange:Z,filterCurvePoints:f,onFilterCurveChange:W,selectedEigenvectorIndex:w,onEigenvectorIndexChange:Ue,isProcessing:n,isAnalyzing:i,isReady:S,isLoadingDefault:h,spectrumInfo:x,hasMesh:!!u,analysisStatus:p}),m.jsxs("div",{className:"canvas-container",children:[F&&m.jsxs("div",{style:{color:"red",padding:"1rem"},children:["Error: ",F]}),m.jsxs(Pn,{camera:{position:[3,2.5,4],fov:50},children:[m.jsx("color",{attach:"background",args:["#0a0a0a"]}),m.jsx("ambientLight",{intensity:.5}),m.jsx("directionalLight",{position:[10,10,5],intensity:1}),m.jsx("directionalLight",{position:[-10,-10,-5],intensity:.3}),m.jsx(dr,{targetPosition:[.9,.75,0],enabled:T&&!!t,onFocused:()=>g(!1)}),u&&m.jsx(dt,{mesh:u,color:"#3b82f6",position:t?[0,0,0]:[0,0,0],label:"Original",boundingInfo:z}),t&&m.jsx(dt,{mesh:t,color:"#22c55e",position:[1.8,0,0],label:`Reconstructed (${a})`,boundingInfo:z}),u&&E&&x&&m.jsx(Un,{mesh:u,eigenvector:E,position:[-1.8,0,0],label:`φ${w}`,boundingInfo:z}),m.jsx(Dn,{args:[10,10],cellColor:"#333",sectionColor:"#555"}),m.jsx(kn,{enableDamping:!0,dampingFactor:.05,rotateSpeed:.5,zoomSpeed:.3,panSpeed:.5})]})]}),m.jsx("footer",{className:"app-footer",children:m.jsx("p",{children:m.jsx("a",{href:"/my-site/python-apps/",children:"← Back to Apps"})})})]})}jn.createRoot(document.getElementById("root")).render(m.jsx(L.StrictMode,{children:m.jsx(mr,{})}));
